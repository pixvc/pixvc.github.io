<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2020/06/10/hello-world/</url>
    <content><![CDATA[<h1 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h1><p>在source/_posts 文件夹下创建.md文件<br>配置属性</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Markdown基本语法</span></span><br><span class="line"><span class="attr">data:</span> <span class="number">2019</span><span class="number">-6</span><span class="number">-10</span></span><br><span class="line"><span class="attr">categories:</span>    </span><br><span class="line"><span class="bullet">-</span> <span class="string">lua语言</span>    <span class="comment">##添加到lua语言分类，也也可以新建一个分类</span></span><br><span class="line"><span class="string">tags：</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">lua</span>        <span class="comment">#添加标签</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">编程</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>文章写完回到终端 hexo g 再 hexo d</p>
<a id="more"></a>

<p>在写博客的时候在文章中使用&lt;!--more--&gt;进行手动截断,这样可以实现只显示摘要的效果，并且在摘要下方生成一个阅读全文的链接</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>Markdown 是一种标记语言，语法简单，易阅读易编写，可以让用户完全脱离鼠标写出样式丰富的文档，广受程序员喜爱，目前许多网站都已经支持通过 Markdown 语法来写文章或者发表评论。 </p>
<h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<h2 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h2><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="strong">*这是斜体*</span> 或 <span class="emphasis">_这也是斜体_</span> </span><br><span class="line">*<span class="strong">*这是粗体*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">*</span>*<span class="strong">*这是加粗斜体*</span>*<span class="strong">*</span></span><br><span class="line"><span class="strong">~~这是删除线~~</span></span><br></pre></td></tr></table></figure>
<p>效果：<br><em>这是斜体</em> 或 <em>这也是斜体</em><br><strong>这是粗体</strong><br><strong><em>这是加粗斜体</em></strong><br><del>这是删除线</del> </p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string"> 表头1</span>|<span class="string">表头2</span>|<span class="string">表头3</span>|<span class="string">表头4</span></span><br><span class="line">|<span class="string">-</span>|<span class="string"> :- </span>|<span class="string"> :-: </span>|<span class="string"> -: </span>|</span><br><span class="line">|<span class="string">默认左对齐</span>|<span class="string">左对齐</span>|<span class="string">居中对其</span>|<span class="string">右对齐</span>|</span><br><span class="line">|<span class="string">默认左对齐</span>|<span class="string">左对齐</span>|<span class="string">居中对其</span>|<span class="string">右对齐</span>|</span><br><span class="line">|<span class="string">默认左对齐</span>|<span class="string">左对齐</span>|<span class="string">居中对其</span>|<span class="string">右对齐</span>|</span><br></pre></td></tr></table></figure>
<p>效果：（表格与文字要有空行）</p>
<table>
<thead>
<tr>
<th>表头1</th>
<th align="left">表头2</th>
<th align="center">表头3</th>
<th align="right">表头4</th>
</tr>
</thead>
<tbody><tr>
<td>默认左对齐</td>
<td align="left">左对齐</td>
<td align="center">居中对其</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td>默认左对齐</td>
<td align="left">左对齐</td>
<td align="center">居中对其</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td>默认左对齐</td>
<td align="left">左对齐</td>
<td align="center">居中对其</td>
<td align="right">右对齐</td>
</tr>
</tbody></table>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">```代码块```  #单行代码一个点包起来</span><br></pre></td></tr></table></figure>


<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">comment</span>]: <span class="link">&lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="symbol">comment</span>]: <span class="link">&lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="symbol">comment</span>]: <span class="link">&lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="symbol">//</span>]: <span class="link">&lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="symbol">//</span>]: <span class="link"># (哈哈我是注释，不会在浏览器中显示。)</span></span><br></pre></td></tr></table></figure>



<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>Markdown中的转义字符为\，可以转义的有：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">\\</span> 反斜杠</span><br><span class="line"><span class="symbol">\`</span> 反引号</span><br><span class="line"><span class="symbol">\*</span> 星号</span><br><span class="line"><span class="symbol">\_</span> 下划线</span><br><span class="line"><span class="symbol">\&#123;</span><span class="symbol">\&#125;</span> 大括号</span><br><span class="line"><span class="symbol">\[</span><span class="symbol">\]</span> 中括号</span><br><span class="line"><span class="symbol">\(</span><span class="symbol">\)</span> 小括号</span><br><span class="line"><span class="symbol">\#</span> 井号</span><br><span class="line"><span class="symbol">\+</span> 加号</span><br><span class="line"><span class="symbol">\-</span> 减号</span><br><span class="line"><span class="symbol">\.</span> 英文句号</span><br><span class="line"><span class="symbol">\!</span> 感叹号</span><br><span class="line"><span class="symbol">\&lt;</span>&gt;尖括号</span><br></pre></td></tr></table></figure>


<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>在 Hexo 中插入图片，首先需要将图片放在 source/images/ 文件夹下，然后如下方式进行插入：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">!<span class="selector-attr">[]</span>(/images/insert_image.jpg)</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="/images/header.jpg" alt=""></p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内形式：[<span class="string">我的博客</span>](<span class="link">http://pixvc.github.io/</span>)</span><br><span class="line">参考形式：[<span class="string">p站</span>][<span class="symbol">1</span>]，[<span class="string">谷歌</span>][<span class="symbol">2</span>]</span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">https://cn.pornhub.com/</span></span><br><span class="line">[<span class="symbol">2</span>]:<span class="link">https://www.google.com/</span></span><br></pre></td></tr></table></figure>
<p>效果：<br>行内形式：<a href="http://pixvc.github.io/">我的博客</a><br>参考形式：[p站][1]，[谷歌][2]<br>[1]:<a href="https://cn.pornhub.com/" target="_blank" rel="noopener">https://cn.pornhub.com/</a><br>[2]:<a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a></p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">**<span class="strong">*</span></span><br><span class="line"><span class="strong">*</span>***<span class="strong">*</span></span><br></pre></td></tr></table></figure>
<h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h2><hr>
<hr>
<hr>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line"><span class="meta">&gt;&gt;</span>这是引用的内容</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>1.无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="bullet">* </span>第二项</span><br><span class="line"><span class="bullet">* </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>第一项</span><br><span class="line"><span class="bullet">+ </span>第二项</span><br><span class="line"><span class="bullet">+ </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>第一项</span><br><span class="line"><span class="bullet">- </span>第二项</span><br><span class="line"><span class="bullet">- </span>第三项</span><br></pre></td></tr></table></figure>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<p>2.有序列表使用数字并加上 . 号来表示，如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 第一项</span><br><span class="line"><span class="number">2.</span> 第二项</span><br><span class="line"><span class="number">3.</span> 第三项</span><br></pre></td></tr></table></figure>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<p>3.列表嵌套只需在子列表中的选项添加四个空格即可：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项：</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2. </span>第二项：</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>makedown</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile基本语法</title>
    <url>/2020/06/10/makefile/</url>
    <content><![CDATA[<h1 id="什么是Makefile"><a href="#什么是Makefile" class="headerlink" title="什么是Makefile"></a>什么是Makefile</h1><p>使用 GCC 编译器在 Linux 进行 C 语言编译，通过在终端执行 gcc 命令来完成 C 文件的编译，如果我们的工程只有一两个 C 文件还好，需要输入的命令不多，当文件有几十、上百甚至上万个的时候用终端输入 GCC 命令的方法显然是不现实的。如果我们能够编写一个文件，这个文件描述了编译哪些源码文件、如何编译那就好了，每次需要编译工程的时只需要使用这个文件就行了。这种问题怎么可能难倒聪明的程序员，为此提出了一个解决大工程编译的工具： make，描述哪些文件需要编译、哪些需要重新编译的文件就叫做 Makefile，命令即可完成整个工程的自动编译，极大的提高了软件开发的效率。</p>
<h1 id="Makefile语法"><a href="#Makefile语法" class="headerlink" title="Makefile语法"></a>Makefile语法</h1><h2 id="Makefile文件的创建和运行"><a href="#Makefile文件的创建和运行" class="headerlink" title="Makefile文件的创建和运行"></a>Makefile文件的创建和运行</h2><p>在工程目录下创建名为“Makefile”的文件，文件名一定要叫做“Makefile”！！！区分大小写</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">main: main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br><span class="line">  gcc -o main main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br><span class="line">main<span class="selector-class">.o</span>: main.c</span><br><span class="line">  gcc -c main.c</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-class">.o</span>: <span class="selector-tag">input</span>.c</span><br><span class="line">  gcc -c <span class="selector-tag">input</span>.c</span><br><span class="line">calcu<span class="selector-class">.o</span>: calcu.c</span><br><span class="line">  gcc -c calcu.c</span><br><span class="line"> </span><br><span class="line">clean:</span><br><span class="line">  rm *.o</span><br><span class="line">  rm main</span><br></pre></td></tr></table></figure>
<p>上述代码中所有行首需要空出来的地方一定要<strong><em>使用“TAB”键！</em></strong>不要使用空格键！ 这是Makefile 的语法要求</p>
<a id="more"></a>

<p>Makefile 编写好以后我们就可以使用 make 命令来编译我们的工程了，直接在命令行中输入“make”即可， make 命令会在当前目录下查找是否存在“Makefile”这个文件，如果存在的话就会按照 Makefile 里面定义的编译方式进行编译。使用命令“make”编译完成以后就会在当前工程目录下生成各种.o 和可执行文件，说明我们编译成功了。</p>
<h2 id="规则格式"><a href="#规则格式" class="headerlink" title="规则格式"></a>规则格式</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">目标…... : 依赖文件集合……</span><br><span class="line">命令 <span class="number">1</span></span><br><span class="line">命令 <span class="number">2</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>比如下面这条规则：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">main : main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br><span class="line">	gcc -o main main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br></pre></td></tr></table></figure>
<p>这条规则的目标是 main， main.o、 input.o 和 calcu.o 是生成 main 的依赖文件，如果要更新目标 main，就必须先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目标也必须更新，“更新”就是执行一遍规则中的命令列表。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">main: main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br><span class="line">  gcc -o main main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br><span class="line">main<span class="selector-class">.o</span>: main.c</span><br><span class="line">  gcc -c main.c</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-class">.o</span>: <span class="selector-tag">input</span>.c</span><br><span class="line">  gcc -c <span class="selector-tag">input</span>.c</span><br><span class="line">calcu<span class="selector-class">.o</span>: calcu.c</span><br><span class="line">  gcc -c calcu.c</span><br><span class="line"> </span><br><span class="line">clean:</span><br><span class="line">  rm *.o</span><br><span class="line">  rm main</span><br></pre></td></tr></table></figure>
<p>上述代码中一共有 5 条规则，1-2 行为第一条规则， 3-4 行为第二条规则， 5-6 行为第三条规则， 7-8 行为第四条规则， 10-12 为第五条规则， make 命令在执行这个 Makefile 的时候其执<br>行步骤如下：<br>首先更新第一条规则中的 main，第一条规则的目标成为默认目标，只要默认目标更新了那么就认为 Makefile 的工作，完成了整个 Makefile 就是为了完成这个工作。在第一次编译的时候由于 main 还不存在，因此第一条规则会执行，第一条规则依赖于文件 main.o、 input.o 和 calcu.o这个三个.o 文件，这三个.o 文件目前还都没有，因此必须先更新这三个文件。 make 会查找以这三个.o 文件为目标的规则并执行。以 main.o 为例，发现更新 main.o 的是第二条规则，因此会执行第二条规则，第二条规则里面的命令为“gcc –c main.c”，这行命令很熟悉了吧，就是不链接编译 main.c，生成 main.o，其它两个.o 文件同理。最后一个规则目标是 clean，它没有依赖文件，因此会默认为依赖文件都是最新的，所以其对应的命令不会执行，当我们想要执行 clean 的话可以直接使用命令“make clean”，执行以后就会删除当前目录下所有的.o 文件以及 main，因此clean 的功能就是完成工程的清理</p>
<h2 id="Makefile变量"><a href="#Makefile变量" class="headerlink" title="Makefile变量"></a>Makefile变量</h2><p><strong><em>不像 C 语言中的变量有 int、 char等各种类型， Makefile 中的变量都是字符串！</em></strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Makefile 变量的使用</span></span><br><span class="line">objects = main.o input.o calcu.o</span><br><span class="line"><span class="section">main: <span class="variable">$(objects)</span></span></span><br><span class="line">  gcc -o main <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>第 1 行是注释， Makefile 中可以写注释，注释开头要用符号“#”，不能用 C 语言中的“//”或者“/**/”！第 2 行我们定义了一个变量 objects，并且给这个变量进行了赋值，其值为字符串“main.o input.o calcu.o”，第 3 和 4 行使用到了变量 objects，Makefile 中变量的引用方法是“$(变量名)”，比如本例中的“$(objects)”就是使用变量 objects。</p>
<h3 id="赋值符"><a href="#赋值符" class="headerlink" title="赋值符"></a>赋值符</h3><p>1.赋值符“=”</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">name = zou</span><br><span class="line">curname = <span class="variable">$(name)</span></span><br><span class="line">name = zouding</span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">  @echo curname: <span class="variable">$(curname)</span></span><br></pre></td></tr></table></figure>
<p>在 Makefile 要输出一串字符的话使用“echo”，就和 C 语言中的“printf”一样，“echo”前面加了个“@”符号，因为 Make 在执行的过程中会自动输出命令执行过程，在命令前面加上“@”的话就不会输出命令执行过程<br>print为zouding，“=”变量的真实值取决于它所引用的变量的最后一次有效值</p>
<p>2.赋值符“：=“</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">name = zou</span><br><span class="line">curname := <span class="variable">$(name)</span></span><br><span class="line">name = zouding</span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">  @echo curname: <span class="variable">$(curname)</span></span><br></pre></td></tr></table></figure>
<p>print的为zou，”:=”只能使用前面赋的值</p>
<p>3.赋值符”？=“<br><code>curname?=zouding</code><br>上述代码的意思就是，如果变量 curname 前面没有被赋值，那么此变量就是“zouding”，如果前面已经赋过值了，那么就使用前面赋的值。</p>
<p>4.追加变量”+=“</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o inpiut.o</span><br><span class="line">objects += calcu.o</span><br></pre></td></tr></table></figure>
<p>一开始变量 objects 的值为“main.o input.o”，后面我们给他追加了一个“calcu.o”，因此变量 objects 变成了<br>“main.o input.o calcu.o”，这个就是变量的追加。</p>
<h2 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h2><p>所谓自动化变量就是这种变量会把模式中所定义的一系列的文件自动的挨个取出，直至所有的符合模式的文件都取完，自动化变量只应该出现在规则的命令中，常用的自动化变量如表 </p>
<table>
<thead>
<tr>
<th>自动化变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>$@</td>
<td align="left">规则中的目标集合，在模式规则中，如果有多个目标的话，“$@”表示匹配模式中定义的目标集合。</td>
</tr>
<tr>
<td>$%</td>
<td align="left">当目标是函数库的时候表示规则中的目标成员名，如果目标不是函数库文件，那么其值为空。</td>
</tr>
<tr>
<td>$&lt;</td>
<td align="left">依赖文件集合中的第一个文件，如果依赖文件是以模式(即“%” )定义的，那么“$&lt;”就是符合模式的一系列的文件集合。</td>
</tr>
<tr>
<td>$?</td>
<td align="left">所有比目标新的依赖目标集合，以空格分开。</td>
</tr>
<tr>
<td>$^</td>
<td align="left">所有依赖文件的集合，使用空格分开，如果在依赖文件中有多个重复的文件，“$^”会去除重复的依赖文件，值保留一份。</td>
</tr>
<tr>
<td>$+</td>
<td align="left">和“$^”类似，但是当依赖文件存在重复的话不会去除重复的依赖文件。</td>
</tr>
<tr>
<td>$*</td>
<td align="left">这个变量表示目标模式中”%”及其之前的部分，如果目标是 test/a.test.c，目标模式为 a.%.c，那么“$*”就是 test/a.test。</td>
</tr>
</tbody></table>
<p>常用的三种：<strong><em>$@、 $&lt;和$^</em></strong></p>
<h2 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h2><p>模式规则中，至少在规则的目标定定义中要包涵“%”，否则就是一般规则，目标中的“%”表示对文件名的匹配，“%”表示长度任意的非空字符串，比如“%.c”就是所有的以.c 结尾的文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">objects</span> = <span class="string">main.o input.o calcu.o</span></span><br><span class="line"><span class="attr">main</span>: <span class="string">$(objects)</span></span><br><span class="line">	<span class="attr">gcc</span> <span class="string">-o main $(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%.o</span> : <span class="string">%.c</span></span><br><span class="line">	<span class="attr">gcc</span> <span class="string">-c $&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">clean</span>:<span class="string"></span></span><br><span class="line">	<span class="attr">rm</span> <span class="string">*.o</span></span><br><span class="line">	<span class="attr">rm</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<p>上诉代码可代替2.1中的代码，更加精简</p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>Makefile 中的函数是已经定义好的，我们直接使用，不支持我们自定义函数。<br>函数的用法如下：<br><code>$(函数名 参数集合）</code></p>
<p>1、函数 subst<br>函数 subst 用来完成字符串替换，调用形式如下：<br><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code><br>此函数的功能是将字符串<text>中的<from>内容替换为<to>，函数返回被替换以后的字符串，比如如下示例：<br><code>$(subst zou,ZZK,my name is zzk)</code><br>把字符串“my name is zzk”中的“zzk”替换为“zou”，替换完成以后的字符串为“my name is zou”。</p>
<p>2、函数 patsubst<br>函数 patsubst 用来完成模式字符串替换，使用方法如下：<br><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code><br>此函数查找字符串<text>中的单词是否符合模式<pattern>，如果匹配就用<replacement>来替换掉， <pattern>可以使用包括通配符“%”，表示任意长度的字符串，函数返回值就是替换后<br>的字符串。如果<replacement>中也包涵“%”，那么<replacement>中的“%”将是<pattern>中的那个“%”所代表的字符串，比如：<br><code>$(patsubst %.c,%.o,a.c b.c c.c)</code><br>将字符串“a.c b.c c.c”中的所有符合“%.c”的字符串，替换为“%.o”，替换完成以后的字符串为“a.o b.o c.o”。</p>
<p>符串为“a.o b.o c.o”。<br>3、函数 dir<br>函数 dir 用来获取目录，使用方法如下：<br><code>$(dir &lt;names…&gt;)</code><br>此函数用来从文件名序列<names>中提取出目录部分，返回值是文件名序列<names>的目录部分，比如：<br><code>$(dir &lt;/src/a.c&gt;)</code><br>提取文件“/src/a.c”的目录部分，也就是“/src”。</p>
<p>4、函数 notdir<br>函数 notdir 看名字就是知道去除文件中的目录部分，也就是提取文件名，用法如下：<br><code>$(notdir &lt;names…&gt;)</code><br>此函数用与从文件名序列<names>中提取出文件名非目录部分，比如：<br><code>$(notdir &lt;/src/a.c&gt;)</code><br>提取文件“/src/a.c”中的非目录部分，也就是文件名“a.c”。</p>
<p>5、函数 foreach<br>foreach 函数用来完成循环，用法如下：<br><code>$(foreach &lt;var&gt;, &lt;list&gt;,&lt;text&gt;)</code><br>此函数的意思就是把参数list中的单词逐一取出来放到参数var中，然后再执行text所包含的表达式。每次text都会返回一个字符串，循环的过程中， text中所包含的每个字符串会以空格隔开，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串将会是函数 foreach 函数的返回值。</p>
]]></content>
      <categories>
        <category>Makefile基本语法</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>lua基本语法</title>
    <url>/2020/06/11/lua%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>两个减号是单行注释<br><code>--</code></p>
<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> --]]</span></span><br></pre></td></tr></table></figure>

<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p> 以下列出了 Lua的保留关键字。保留关键字不能作为常量或变量或其他用户自定义标示符：</p>
<table>
<thead>
<tr>
<th>and</th>
<th>break</th>
<th>do</th>
<th>else</th>
</tr>
</thead>
<tbody><tr>
<td>elseif</td>
<td>end</td>
<td>false</td>
<td>for</td>
</tr>
<tr>
<td>function</td>
<td>if</td>
<td>in</td>
<td>local</td>
</tr>
<tr>
<td>nil</td>
<td>not</td>
<td>or</td>
<td>repeat</td>
</tr>
<tr>
<td>return</td>
<td>then</td>
<td>true</td>
<td>until</td>
</tr>
<tr>
<td>while</td>
<td>goto</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="lua变量"><a href="#lua变量" class="headerlink" title="lua变量"></a>lua变量</h1><p>Lua 变量有三种类型：全局变量、局部变量、表中的域。</p>
<p><strong>Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- test.lua 文件脚本</span></span><br><span class="line">a = <span class="number">5</span>               <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">5</span>         <span class="comment">-- 局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joke</span><span class="params">()</span></span></span><br><span class="line">    c = <span class="number">5</span>           <span class="comment">-- 全局变量</span></span><br><span class="line">    <span class="keyword">local</span> d = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line"><span class="built_in">print</span>(c,d)          <span class="comment">--&gt; 5 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line">    b = <span class="number">6</span>           <span class="comment">-- 对局部变量重新赋值</span></span><br><span class="line">    <span class="built_in">print</span>(a,b);     <span class="comment">--&gt; 6 6</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,b)      <span class="comment">--&gt; 5 6</span></span><br></pre></td></tr></table></figure>



<h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><p>Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。<br><code>a,b=10,20   --a=10,b=20</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a,b,c)</span></span>             --&gt; <span class="number">0</span>   <span class="number">1</span>   nil</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> = a+<span class="number">1</span>, b+<span class="number">1</span>, b+<span class="number">2</span>     -- value of b+<span class="number">2</span> is ignored</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a,b)</span></span>               --&gt; <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a,b,c)</span></span>             --&gt; <span class="number">0</span>   nil   nil</span><br></pre></td></tr></table></figure>

<p><code>a, b = f()</code><br>f()返回两个值，第一个赋给a，第二个赋给b。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>对 table 的索引使用方括号 []。Lua 也提供了 . 操作</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">t[i]</span><br><span class="line">t<span class="selector-class">.i</span>                 -- 当索引为字符串类型时的一种简化写法</span><br><span class="line"><span class="function"><span class="title">gettable_event</span><span class="params">(t,i)</span></span> -- 采用索引访问本质上是一个类似这样的函数调用</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> site = &#123;&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> site[<span class="string">"key"</span>] = <span class="string">"www.runoob.com"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">print</span>(site[<span class="string">"key"</span>])</span></span><br><span class="line">www.runoob.com</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">print</span>(site.key)</span></span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>lua数据类型</title>
    <url>/2020/06/11/lua%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nil</td>
<td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td>
</tr>
<tr>
<td>boolean</td>
<td>包含两个值：false和true。</td>
</tr>
<tr>
<td>number</td>
<td>表示双精度类型的实浮点数</td>
</tr>
<tr>
<td>string</td>
<td>字符串由一对双引号或单引号来表示</td>
</tr>
<tr>
<td>function</td>
<td>由 C 或 Lua 编写的函数</td>
</tr>
<tr>
<td>userdata</td>
<td>表示任意存储在变量中的C数据结构</td>
</tr>
<tr>
<td>thread</td>
<td>表示执行的独立线路，用于执行协同程序</td>
</tr>
<tr>
<td>table</td>
<td>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td>
</tr>
</tbody></table>
<a id="more"></a>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(<span class="string">"Hello world"</span>))</span>      --&gt;</span> string</span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(<span class="number">10.4</span>*<span class="number">3</span>))</span>             --&gt;</span> number</span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(<span class="built_in">print</span>))</span>              --&gt;</span> <span class="keyword">function</span></span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(type))</span>               --&gt;</span> <span class="keyword">function</span></span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(<span class="literal">true</span>))</span>               --&gt;</span> boolean</span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(nil))</span>                --&gt;</span> nil</span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(type(X)))</span>            --&gt;</span> string</span><br></pre></td></tr></table></figure>


<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>nil 类型表示一种没有任何有效值，它只有一个值 – nil，例如打印一个没有赋值的变量，便会输出一个 nil 值：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">&gt; print(<span class="name">type</span>(<span class="name">a</span>))</span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉</p>
<p>nil 作比较时应该加上双引号 “：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">type</span>(<span class="type">X</span>)</span><br><span class="line"><span class="title">nil</span></span><br><span class="line">&gt; <span class="keyword">type</span>(<span class="type">X</span>)==nil</span><br><span class="line"><span class="title">false</span></span><br><span class="line">&gt; <span class="keyword">type</span>(<span class="type">X</span>)=="nil"</span><br><span class="line"><span class="title">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><p>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是 false，其他的都为 true，<strong><em>数字 0 也是 true</em></strong></p>
<hr>
<h2 id="number（数字）"><a href="#number（数字）" class="headerlink" title="number（数字）"></a>number（数字）</h2><p>Lua 默认只有一种 number 类型 – double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型</p>
<hr>
<h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p>字符串由一对双引号或单引号来表示。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">string1</span> = <span class="string">"this is string1"</span></span><br><span class="line"><span class="attr">string2</span> = <span class="string">'this is string2'</span></span><br></pre></td></tr></table></figure>
<p>也可以用 2 个方括号 “[[]]” 来表示”一块”字符串。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">html = [[</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.runoob.com/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">]]</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure>

<p>在对一个数字字符串上进行算术操作时，Lua会尝试将这个数字字符串转成一个数字</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="title">print</span>(<span class="string">"2"</span> + <span class="number">6</span>)</span></span><br><span class="line"><span class="number">8.0</span></span><br><span class="line">&gt; <span class="function"><span class="title">print</span>(<span class="string">"2"</span> + <span class="string">"6"</span>)</span></span><br><span class="line"><span class="number">8.0</span></span><br><span class="line">&gt; <span class="function"><span class="title">print</span>(<span class="string">"2 + 6"</span>)</span></span><br><span class="line"><span class="number">2</span> + <span class="number">6</span></span><br><span class="line">&gt; <span class="function"><span class="title">print</span>(<span class="string">"-2e2"</span> * <span class="string">"6"</span>)</span></span><br><span class="line">-<span class="number">1200.0</span></span><br></pre></td></tr></table></figure>
<p>字符串连接使用的是 ..  如</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; <span class="builtin-name">print</span>(<span class="string">"a"</span> <span class="built_in">..</span> <span class="string">'b'</span>)</span><br><span class="line">ab</span><br><span class="line">&gt; <span class="builtin-name">print</span>(157 <span class="built_in">..</span> 428)</span><br><span class="line">157428</span><br></pre></td></tr></table></figure>

<p>使用 # 来计算字符串的长度，放在字符串前面</p>
<figure class="highlight plain"><figcaption><span>len </span></figcaption><table><tr><td class="code"><pre><span class="line">&gt; print(#len)</span><br><span class="line">14</span><br><span class="line">&gt; print(#&quot;www.runoob.com&quot;)</span><br><span class="line">14</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="table表"><a href="#table表" class="headerlink" title="table表"></a>table表</h2><p>在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:<br><code>local tbl1 = {}  --创建一个空表</code><br><code>local tbl2 = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}  --初始化表</code></p>
<p>不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="string">"key"</span>] = <span class="string">"value"</span></span><br><span class="line"><span class="type">key</span> = <span class="number">10</span></span><br><span class="line">a[<span class="type">key</span>] = <span class="number">22</span></span><br><span class="line">a[<span class="type">key</span>] = a[<span class="type">key</span>] + <span class="number">11</span></span><br><span class="line">for k, v in pairs(a) do</span><br><span class="line">    print(k .. <span class="string">" : "</span> .. v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key :</span> <span class="string">value</span></span><br><span class="line"><span class="attr">10 :</span> <span class="number">33</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua循环</title>
    <url>/2020/06/11/lua%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><h2 id="数值for循环"><a href="#数值for循环" class="headerlink" title="数值for循环"></a>数值for循环</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var=<span class="built_in">exp1</span>,<span class="built_in">exp2</span>,exp3 <span class="built_in">do</span>  </span><br><span class="line">    &lt;执行体&gt;  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 “执行体”。exp3 是可选的，如果不指定，<strong>默认为1。</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"function"</span>)  </span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,f(<span class="number">5</span>) <span class="keyword">do</span> <span class="built_in">print</span>(i)  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>for的三个表达式在循环开始前一次性求值，以后不再进行求值。比如上面的f(x)只会在循环开始前执行一次，其结果用在后面的循环中。</p>
<a id="more"></a>

<p>验证如下:<br>执行结果：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">function</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型for循环"><a href="#泛型for循环" class="headerlink" title="泛型for循环"></a>泛型for循环</h2><p>泛型 for 循环通过一个迭代器函数来遍历所有值，类似 java 中的 foreach 语句。<br>Lua 编程语言中泛型 for 循环语法格式:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>i是数组索引值，v是对应索引的数组元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组。<br>执行结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>one</span><br><span class="line"><span class="symbol">2 </span>two</span><br><span class="line"><span class="symbol">3 </span>three</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">statements</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>statements(循环体语句) 可以是一条或多条语句，condition(条件) 可以是任意表达式，在 condition(条件) 为 true 时执行循环体语句。</p>
<hr>
<h1 id="repeat…until-循环"><a href="#repeat…until-循环" class="headerlink" title="repeat…until 循环"></a>repeat…until 循环</h1><p> repeat…until 循环语句不同于 for 和 while循环，for 和 while 循环的条件语句在当前循环执行开始时判断，而 repeat…until 循环的条件语句在当前循环结束后判断<br> <figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"> repeat</span><br><span class="line">   <span class="built_in">statements</span></span><br><span class="line"><span class="keyword">until</span>( condition )</span><br></pre></td></tr></table></figure><br>循环条件判断语句（condition）在循环体末尾部分，所以在条件进行判断前循环体都会执行一次。<strong>如果条件判断语句（condition）为 false，循环会重新开始执行，直到条件判断语句（condition）为 true 才会停止执行。</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">a</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">--[ 执行循环 --]</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   print(<span class="string">"a的值为:"</span>, <span class="keyword">a</span>)</span><br><span class="line">   <span class="keyword">a</span> = <span class="keyword">a</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span>( <span class="keyword">a</span> &gt; <span class="number">15</span> )</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">a的值为:    <span class="number">10</span></span><br><span class="line">a的值为:    <span class="number">11</span></span><br><span class="line">a的值为:    <span class="number">12</span></span><br><span class="line">a的值为:    <span class="number">13</span></span><br><span class="line">a的值为:    <span class="number">14</span></span><br><span class="line">a的值为:    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h1><p>语法格式如下所示<br><code>goto Label</code><br>Label 的格式为：<br><code>:: Label ::</code></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">local a = 1</span><br><span class="line"><span class="meta">::label::</span> print("--- goto label ---")</span><br><span class="line"></span><br><span class="line">a = a+1</span><br><span class="line">if a &lt; 3 then</span><br><span class="line"><span class="code">    goto label   -- a 小于 3 的时候跳转到标签 label</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">--<span class="literal">-</span> <span class="comment">goto</span> <span class="comment">label</span> --<span class="literal">-</span></span><br><span class="line">--<span class="literal">-</span> <span class="comment">goto</span> <span class="comment">label</span> --<span class="literal">-</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="variable">then</span></span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="string">"0 为 true"</span>)</span></span><br><span class="line"><span class="variable">end</span></span><br></pre></td></tr></table></figure>

<p>if else</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(布尔表达式)</span></span><br><span class="line"><span class="variable">then</span></span><br><span class="line">   --[ 布尔表达式为 <span class="variable"><span class="literal">true</span></span> 时执行该语句块 --]</span><br><span class="line"><span class="variable"><span class="keyword">else</span></span></span><br><span class="line">   --[ 布尔表达式为 <span class="variable"><span class="literal">false</span></span> 时执行该语句块 --]</span><br><span class="line"><span class="variable">end</span></span><br></pre></td></tr></table></figure>

<p>if…elesif…else</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">if(</span> <span class="string">布尔表达式</span> <span class="number">1</span><span class="string">)</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line">   <span class="string">--[</span> <span class="string">在布尔表达式</span> <span class="number">1</span> <span class="string">为</span> <span class="literal">true</span> <span class="string">时执行该语句块</span> <span class="string">--]</span></span><br><span class="line"></span><br><span class="line"><span class="string">elseif(</span> <span class="string">布尔表达式</span> <span class="number">2</span><span class="string">)</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line">   <span class="string">--[</span> <span class="string">在布尔表达式</span> <span class="number">2</span> <span class="string">为</span> <span class="literal">true</span> <span class="string">时执行该语句块</span> <span class="string">--]</span></span><br><span class="line"></span><br><span class="line"><span class="string">elseif(</span> <span class="string">布尔表达式</span> <span class="number">3</span><span class="string">)</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line">   <span class="string">--[</span> <span class="string">在布尔表达式</span> <span class="number">3</span> <span class="string">为</span> <span class="literal">true</span> <span class="string">时执行该语句块</span> <span class="string">--]</span></span><br><span class="line"><span class="string">else</span> </span><br><span class="line">   <span class="string">--[</span> <span class="string">如果以上布尔表达式都不为</span> <span class="literal">true</span> <span class="string">则执行该语句块</span> <span class="string">--]</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>lua函数</title>
    <url>/2020/06/12/Lua%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>函数定义</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">optional_function_scope <span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">( argument1, argument2, argument3<span class="rest_arg">..., argumentn</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">function_body</span></span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">result_params_comma_separated</span></span></span><br><span class="line"><span class="function"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>解析：</p>
<ul>
<li>optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。</li>
<li>function_name: 指定函数名称。</li>
<li>argument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。</li>
<li>function_body: 函数体，函数中需要执行的代码语句块。</li>
<li>result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。</li>
</ul>
<hr>
<h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p>Lua函数可以返回多个结果值，在return后列出要返回的值的列表即可返回多值</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maximum</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">local</span> mi = <span class="number">1</span>             <span class="comment">-- 最大值索引</span></span><br><span class="line">    <span class="keyword">local</span> m = a[mi]          <span class="comment">-- 最大值</span></span><br><span class="line">    <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">       <span class="keyword">if</span> val &gt; m <span class="keyword">then</span></span><br><span class="line">           mi = i</span><br><span class="line">           m = val</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> m, mi</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(maximum(&#123;<span class="number">8</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">5</span>&#125;))</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="number">23</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 … 表示函数有可变的参数</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">function add(...)  </span><br><span class="line">local s = <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">for</span> i, v <span class="keyword">in</span> ipairs<span class="meta">&#123;...&#125;</span> <span class="keyword">do</span>   --&gt; <span class="meta">&#123;...&#125;</span> 表示一个由所有变长参数构成的数组  </span><br><span class="line">    s = s + v  </span><br><span class="line">  <span class="keyword">end</span>  </span><br><span class="line">  <span class="keyword">return</span> s  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line">print(add(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>))  ---&gt;<span class="number">25</span></span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">function average(...)</span><br><span class="line">   <span class="literal">result</span> = <span class="number">0</span></span><br><span class="line">   local arg=<span class="meta">&#123;...&#125;</span>    --&gt; arg 为一个表，局部变量</span><br><span class="line">   <span class="keyword">for</span> i,v <span class="keyword">in</span> ipairs(arg) <span class="keyword">do</span></span><br><span class="line">      <span class="literal">result</span> = <span class="literal">result</span> + v</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   print(<span class="string">"总共传入 "</span> .. <span class="comment">#arg .. " 个数")</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">result</span>/<span class="comment">#arg</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"平均值为"</span>,average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>


<p>有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fwrite</span><span class="params">(fmt, ...)</span></span>  <span class="comment">---&gt; 固定的参数fmt</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt, ...))    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fwrite(<span class="string">"runoob\n"</span>)       <span class="comment">---&gt;fmt = "runoob", 没有变长参数。  </span></span><br><span class="line">fwrite(<span class="string">"%d%d\n"</span>, <span class="number">1</span>, <span class="number">2</span>)   <span class="comment">---&gt;fmt = "%d%d", 变长参数为 1 和 2</span></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">runoob</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>通常在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select(‘#’, …) 或者 select(n, …)</p>
<p>select(‘#’, …) 返回可变参数的长度<br>select(n, …) 用于返回 n 到 select(‘#’,…) 的参数</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(<span class="rest_arg">...)  </span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="rest_arg">        for</span> i = 1, select(<span class="string">'#'</span>, <span class="rest_arg">...) do</span>  --&gt;获取参数总数</span></span></span><br><span class="line"><span class="function"><span class="params">            local arg = select(i, <span class="rest_arg">...); --&gt;读取参数</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="rest_arg">            print</span>(<span class="string">"arg"</span>, arg)</span></span>;  </span><br><span class="line">        end  </span><br><span class="line">    end  </span><br><span class="line"> </span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言中对可变参数列表的简单理解</title>
    <url>/2020/06/12/c%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E6%95%B0%E7%9B%AE%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>C中变长实参头文件stdarg.h提供了一个数据类型va-list和三个宏（va-start、va-arg和va-end），用它们在被调用函数不知道参数个数和类型时对可变参数表进行测试，从而为访问可变参数提供了方便且有效的方法。va-list是一个char类型的指针，当被调用函数使用一个可变参数时，它声明一个类型为va-list的变量，该变量用来指向va-arg和va-end所需信息的位置。下面给出va_list、va-start、va-arg和va-end在C中的源码：<br><code>typedef char *  va_list;</code><br><code>#define va_start(ap,v)  ( ap = (va_list)&amp;v + _INTSIZEOF(v) )   //得到可变参数中第一个参数的首地址</code><br><code>#define va_arg(ap,type)    ( *(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)) )    //将参数转换成需要的类型，并使ap指向下一个参数</code><br><code>#define va_end(ap)      ( ap = (va_list)0 )//功能就是把指针ap赋值为0，使它不指向内存的变量</code></p>
<a id="more"></a>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> <span class="comment">/*函数sum中首先定义了可变参数表指针vap，而后通过va_start ( vap, n )取得了参数表首地址（赋值给了vap），</span></span><br><span class="line"><span class="comment"> 其后的for循环则用来遍历可变参数表。*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i , sum = <span class="number">0</span>;</span><br><span class="line">	va_list vap;  <span class="comment">//声明va_list变量</span></span><br><span class="line">	va_start(vap , n);     <span class="comment">//指向可变参数表中的第一个参数</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; ++i)</span><br><span class="line">		sum += va_arg(vap , <span class="keyword">int</span>);     <span class="comment">//取出可变参数表中的参数，并修改参数指针vap使其增加以指向表中下一个参数</span></span><br><span class="line">	va_end(vap);    <span class="comment">//把指针vap赋值为0</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = sum(<span class="number">3</span> , <span class="number">45</span> , <span class="number">89</span> , <span class="number">72</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数原型声明，至少需要一个确定的参数，注意括号内的省略号</li>
<li>在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)；</li>
<li>然后应该对ap进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“…”之前的那个参数；</li>
<li>然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把ap的位置指向变参表的下一个变量位置；</li>
<li>获取所有的参数之后，我们有必要将这个ap指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数ap置为NULL，应该养成获取完参数表之后关闭指针的习惯。通常va_start和va_end是成对出现。<strong>va-end必须在va-arg读完所有参数后再调用</strong></li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua迭代器</title>
    <url>/2020/06/12/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="ipairs-和pairs-的区别"><a href="#ipairs-和pairs-的区别" class="headerlink" title="ipairs()和pairs()的区别"></a>ipairs()和pairs()的区别</h1><p>pairs会遍历表中所有的key-value值，而ipairs会根据key的数值从1开始加1递增遍历对应的table[i]值，直到出现第一个不是按1递增的数值时候退出。</p>
<p>下面我们以例子说明一下吧</p>
<p>stars = {[1] = “Sun”, [2] = “Moon”, [5] = ‘Earth’}</p>
<p>for i, v in pairs(stars) do</p>
<p>   print(i, v)</p>
<p>end</p>
<a id="more"></a>

<p>使用pairs()将会遍历表中所有的数据，输出结果是：</p>
<p>1    Sun<br>2    Moon<br>5    Earth</p>
<p>如果使用ipairs()的话，</p>
<p>for i, v in ipairs(stars) do</p>
<p>   print(i, v)</p>
<p>end</p>
<p>当i的值遍历到第三个元素时，i的值为5，此时i并不是上一个次i值（2）的+1递增，所以遍历结束，结果则会是：</p>
<p>1    Sun<br>2    Moon</p>
<p>ipairs()和pairs()的区别就是这么简单。</p>
<h1 id="泛型-for-迭代器"><a href="#泛型-for-迭代器" class="headerlink" title="泛型 for 迭代器"></a>泛型 for 迭代器</h1><p>泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。<br>泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<!--more-->


<p>上面代码中，k, v为变量列表；pairs(t)为表达式列表。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">array</span> = &#123;"Google", "Runoob"&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for key</span>,<span class="keyword">value</span> <span class="keyword">in</span> ipairs(<span class="keyword">array</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   print(key, <span class="keyword">value</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">执行结果：</span><br><span class="line"><span class="number">1</span>  Google</span><br><span class="line"><span class="number">2</span>  Runoob</span><br></pre></td></tr></table></figure>

<p>Lua 默认提供的迭代函数 ipairs。</p>
<p>泛型 for 的执行过程：</p>
<ul>
<li>首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。</li>
<li>第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。</li>
<li>第三，将迭代函数返回的值赋给变量列表。</li>
<li>第四，如果返回的第一个值为nil循环结束，否则执行循环体。</li>
<li>第五，回到第二步再次调用迭代函数</li>
</ul>
<h1 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h1><p>无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。</p>
<p>每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素。</p>
<p>以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">--求数字<span class="built_in">j</span>到N的平方</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(N, j)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">j</span> &lt;= N</span><br><span class="line">    then</span><br><span class="line">        <span class="keyword">return</span>  <span class="built_in">j</span>+<span class="number">1</span> ,  <span class="built_in">j</span>*<span class="built_in">j</span> --  这里的<span class="built_in">j</span>+<span class="number">1</span> 是为了传给<span class="keyword">for</span>的<span class="built_in">i</span>值，类似++<span class="built_in">i</span>，否则<span class="built_in">i</span>一直不变，死循环</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">--         迭代器函数、恒定状态、控制变量的初值</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>,n in square ,     <span class="number">3</span> ,    <span class="number">1</span></span><br><span class="line">do</span><br><span class="line">    --这里的<span class="built_in">i</span>,n是square返回的</span><br><span class="line">    print(<span class="built_in">i</span><span class="number">-1</span> ,<span class="string">"的平方是"</span> , n)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iter</span> <span class="params">(a, i)</span></span></span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span></span><br><span class="line">    local v = a[<span class="built_in">i</span>]</span><br><span class="line">    <span class="keyword">if</span> v then</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">i</span>, v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> iter, a, <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当 Lua 调用 ipairs(a) 开始循环时，他获取三个值：迭代函数 iter、状态常量 a、控制变量初始值 0；然后 Lua 调用 iter(a,0) 返回 1, a[1]（除非 a[1]=nil）；第二次迭代调用 iter(a,1) 返回 2, a[2]……直到第一个 nil 元素。</p>
<h1 id="多状态的迭代器"><a href="#多状态的迭代器" class="headerlink" title="多状态的迭代器"></a>多状态的迭代器</h1><p>很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到 table 内，将 table 作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在 table 内，所以迭代函数通常不需要第二个参数。</p>
<p>以下实例我们创建了自己的迭代器：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">array</span> = &#123;"Google", "Runoob"&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> elementIterator (collection)</span><br><span class="line">   <span class="keyword">local</span> <span class="keyword">index</span> = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> count = #collection</span><br><span class="line">   <span class="comment">-- 闭包函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">function</span> ()</span><br><span class="line">      <span class="keyword">index</span> = <span class="keyword">index</span> + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">index</span> &lt;= count</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">         <span class="comment">--  返回迭代器的当前元素</span></span><br><span class="line">         <span class="keyword">return</span> collection[<span class="keyword">index</span>]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elementIterator(<span class="keyword">array</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   print(element)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Google</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure>
<p>以上实例中我们可以看到，elementIterator 内使用了闭包函数，实现计算集合大小并输出各个元素。</p>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>表和元表</title>
    <url>/2020/06/15/%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><p>table 是Lua的一种数据结构用来帮助我们创建不同的数据类型，如：数组、字典等。<br>Lua table使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。<br>Lua table 是不固定大小的，你可以根据自己需要进行扩容。</p>
<h2 id="table-表-的构造"><a href="#table-表-的构造" class="headerlink" title="table(表)的构造"></a>table(表)的构造</h2><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">-- 初始化表</span><br><span class="line">mytable = &#123;&#125;</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;  --索引默认为<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"></span><br><span class="line">-- 指定值</span><br><span class="line">mytable[<span class="number">1</span>]= <span class="string">"Lua"</span></span><br><span class="line"></span><br><span class="line">-- 移除引用</span><br><span class="line">mytable = nil</span><br><span class="line">-- lua 垃圾回收会释放内存</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="Table-操作"><a href="#Table-操作" class="headerlink" title="Table 操作"></a>Table 操作</h2><ul>
<li>table.concat (table [, sep [, start [, end]]]):<br>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">fruits = &#123;<span class="string">"banana"</span>,<span class="string">"orange"</span>,<span class="string">"apple"</span>&#125;</span><br><span class="line"><span class="comment">-- 返回 table 连接后的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"连接后的字符串 "</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定连接字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"连接后的字符串 "</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits,<span class="string">", "</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定索引来连接 table</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"连接后的字符串 "</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits,<span class="string">", "</span>, <span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure></li>
<li>table.insert (table, [pos,] value):<br>在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</li>
<li>table.maxn (table)<br>指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现)</li>
<li>table.remove (table [, pos])<br>返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</li>
<li>table.sort (table [, comp])<br>对给定的table进行升序排序。</li>
</ul>
<h1 id="Lua-元表-Metatable"><a href="#Lua-元表-Metatable" class="headerlink" title="Lua 元表(Metatable)"></a>Lua 元表(Metatable)</h1><p>元表 (metatable) 的表现行为类似于 C++ 语言中的操作符重载，例如我们可以重载 “<strong>add” 元方法 (metamethod)，来计算两个 Lua 数组的并集；或者重载 “</strong>index” 方法，来定义我们自己的 Hash 函数。Lua 提供了两个十分重要的用来处理元表的方法，如下：</p>
<ul>
<li>setmetatable(table,metatable): 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。</li>
<li>getmetatable(table): 返回对象的元表(metatable)。</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = &#123;&#125;                          <span class="comment">-- 普通表</span></span><br><span class="line">mymetatable = &#123;&#125;                      <span class="comment">-- 元表</span></span><br><span class="line"><span class="built_in">setmetatable</span>(mytable,mymetatable)     <span class="comment">-- 把 mymetatable 设为 mytable 的元表</span></span><br></pre></td></tr></table></figure>
<p>以上代码也可以直接写成一行：<br><code>mytable = setmetatable({},{})</code><br>以下为返回对象元表：<br><code>getmetatable(mytable)                 -- 这回返回mymetatable</code></p>
<h2 id="index-元方法"><a href="#index-元方法" class="headerlink" title="__index 元方法"></a>__index 元方法</h2><p>当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的<strong>index 键。如果</strong>index包含一个表格，Lua会在表格中查找相应的键。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ lua</span><br><span class="line">Lua <span class="number">5.3</span><span class="number">.0</span>  Copyright (C) <span class="number">1994</span><span class="number">-2015</span> Lua.org, PUC-Rio</span><br><span class="line">&gt; other = &#123; foo = <span class="number">3</span> &#125;</span><br><span class="line">&gt; t = setmetatable(&#123;&#125;, &#123; __index = other &#125;)</span><br><span class="line">&gt; t.foo</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; t.bar</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>
<p>如果__index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。<br>__index 元方法查看表中元素是否存在，如果不存在，返回结果为 nil；如果存在则由 __index 返回结果。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;key1 = <span class="string">"value1"</span>&#125;, &#123;</span><br><span class="line">  <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(mytable, key)</span></span></span><br><span class="line">    <span class="keyword">if</span> key == <span class="string">"key2"</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"metatablevalue"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>
<p>实例解析：</p>
<ul>
<li>mytable 表赋值为 {key1 = “value1”}。</li>
<li>mytable 设置了元表，元方法为 __index。<br>在mytable表中查找 key1，如果找到，返回该元素，找不到则继续。</li>
<li>在mytable表中查找 key2，如果找到，返回 metatablevalue，找不到则继续。</li>
<li>判断元表有没有<strong>index方法，如果</strong>index方法是一个函数，则调用该函数。</li>
<li>元方法中查看是否传入 “key2” 键的参数（mytable.key2已设置），如果传入 “key2” 参数返回 </li>
</ul>
<p>“metatablevalue”，否则返回 mytable 对应的键值。<br>我们可以将以上代码简单写成：<code>mytable = setmetatable({key1 = &quot;value1&quot;}, { __index = { key2 = &quot;metatablevalue&quot; } })</code></p>
<h2 id="newindex-元方法"><a href="#newindex-元方法" class="headerlink" title="__newindex 元方法"></a>__newindex 元方法</h2><p><strong>newindex 元方法用来对表更新，</strong>index则用来对表访问 。<br>当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则调用这个函数而不进行赋值操作。<br>以下实例演示了 __newindex 元方法的应用：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">mymetatable = &#123;&#125;</span><br><span class="line">mytable = setmetatable(&#123;key1 = <span class="string">"value1"</span>&#125;, &#123; __newindex = mymetatable &#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(mytable.key1)</span></span></span><br><span class="line"></span><br><span class="line">mytable<span class="selector-class">.newkey</span> = <span class="string">"新值2"</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(mytable.newkey,mymetatable.newkey)</span></span></span><br><span class="line"></span><br><span class="line">mytable<span class="selector-class">.key1</span> = <span class="string">"新值1"</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(mytable.key1,mymetatable.key1)</span></span></span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">value1</span><br><span class="line">nil    新值<span class="number">2</span></span><br><span class="line">新值<span class="number">1</span>    nil</span><br></pre></td></tr></table></figure>
<p>以上实例中表设置了元方法 __newindex，在对新索引键（newkey）赋值时（mytable.newkey = “新值2”），会调用元方法，而不进行赋值。而如果对已存在的索引键（key1），则会进行赋值，而不调用元方法 __newindex。</p>
<h2 id="call-元方法"><a href="#call-元方法" class="headerlink" title="__call 元方法"></a>__call 元方法</h2><p>__call 元方法在 Lua 调用一个值时调用。</p>
<h2 id="修改表的操作符行为"><a href="#修改表的操作符行为" class="headerlink" title="修改表的操作符行为"></a>修改表的操作符行为</h2><p>通过重载 “__add” 元方法来计算集合的并集实例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> set1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;   <span class="comment">-- 集合</span></span><br><span class="line"><span class="keyword">local</span> set2 = &#123;<span class="number">20</span>, <span class="number">40</span>, <span class="number">50</span>&#125;   <span class="comment">-- 集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将用于重载__add的函数，注意第一个参数是self</span></span><br><span class="line"><span class="keyword">local</span> union = <span class="function"><span class="keyword">function</span> <span class="params">(self, another)</span></span></span><br><span class="line">    <span class="keyword">local</span> set = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> result = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 利用数组来确保集合的互异性</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">pairs</span>(self) <span class="keyword">do</span> set[j] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">pairs</span>(another) <span class="keyword">do</span> set[j] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 加入结果集合</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">pairs</span>(set) <span class="keyword">do</span> <span class="built_in">table</span>.<span class="built_in">insert</span>(result, i) <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">setmetatable</span>(set1, &#123;<span class="built_in">__add</span> = union&#125;) <span class="comment">-- 重载 set1 表的 __add 元方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> set3 = set1 + set2</span><br><span class="line"><span class="keyword">for</span> _, j <span class="keyword">in</span> <span class="built_in">pairs</span>(set3) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(j..<span class="string">" "</span>)               <span class="comment">--&gt;output：30 50 20 40 10</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>除了加法可以被重载之外，Lua 提供的所有操作符都可以被重载：</p>
<table>
<thead>
<tr>
<th>元方法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>“__add”</td>
<td>+ 操作</td>
</tr>
<tr>
<td>“__sub”</td>
<td>- 操作 其行为类似于 “add” 操作</td>
</tr>
<tr>
<td>“__mul”</td>
<td>* 操作 其行为类似于 “add” 操作</td>
</tr>
<tr>
<td>“__div”</td>
<td>/ 操作 其行为类似于 “add” 操作</td>
</tr>
<tr>
<td>“__mod”</td>
<td>% 操作 其行为类似于 “add” 操作</td>
</tr>
<tr>
<td>“__pow”</td>
<td>^ （幂）操作 其行为类似于 “add” 操作</td>
</tr>
<tr>
<td>“__unm”</td>
<td>一元 - 操作</td>
</tr>
<tr>
<td>“__len”</td>
<td># 操作</td>
</tr>
<tr>
<td>“__eq”</td>
<td>== 操作 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作</td>
</tr>
<tr>
<td>“__lt”</td>
<td>&lt; 操作</td>
</tr>
<tr>
<td>“__le”</td>
<td>&lt;= 操作</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
</search>
