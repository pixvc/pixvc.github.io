<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SPI原理</title>
    <url>/2020/06/19/SPI/</url>
    <content><![CDATA[<p>SPI 协议是由摩托罗拉公司提出的通讯协议(Serial Peripheral Interface)，即串行外围设备接口，是一种高速全双工的通信总线。它被广泛地使用在 ADC、 LCD 等设备与 MCU 间，要求通讯速率较高的场合。</p>
<p>SPI接口具有如下优点：</p>
<ul>
<li>支持全双工操作；</li>
<li>操作简单；</li>
<li>数据传输速率较高。</li>
</ul>
<p>SPI接口具有如下缺点：</p>
<ul>
<li>需要占用主机较多的口线（每个从机都需要一根片选线）；</li>
<li>只支持单个主机。</li>
<li>没有指定的流控制，没有应答机制确认是否接收到数据。</li>
</ul>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p><img src="/images/13.png" alt=""></p>
<a id="more"></a>

<p>SPI 通讯使用 3 条总线及片选线， 3 条总线分别为 SCK、 MOSI、 MISO，片选线为 SS，它们的作用介绍如下： </p>
<ol>
<li>nSS(Slave Select)：片选信号线，用于选中SPI从设备。每个从设备独立拥有这条nSS信号线，占据主机的一个引脚。设备的其他总线是并联到SPI主机的，即无论多少个从设备，都共同使用这3条总线。当从设备上的nSS引脚被置拉低时表明该从设备被主机选中。</li>
<li>SCK(Serial Clock)：时钟信号线，通讯数据同步用。时钟信号由通讯主机产生，它决定了SPI的通讯速率。</li>
<li>MOSI(Master Ouput Slave Input)：主机(数据)输出/从设备(数据)输入引脚，即这条信号线上传输从主机到从机的数据。</li>
<li>MISO(Master Input Slave Ouput)：主机(数据)输入/从设备(数据)输出引脚，即这条信号线上传输从机从到主机的数据主从机通过两条信号线来传输数据，那么自然是全双工通讯的了。之前的I2C通讯，数据只在一条SDA线上传输，主从机数据交互只能采用半双工。</li>
</ol>
<h1 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h1><p>与 I2C 的类似， SPI 协议定义了通讯的起始和停止信号、数据有效性、时钟同步等环节。</p>
<h2 id="SPI-基本通讯过程"><a href="#SPI-基本通讯过程" class="headerlink" title="SPI 基本通讯过程"></a>SPI 基本通讯过程</h2><p> SPI 通讯的通讯时序<br><img src="/images/12.png" alt=""><br>这是一个主机的通讯时序。 NSS、 SCK、 MOSI 信号都由主机控制产生，而 MISO 的信号由从机产生，主机通过该信号线读取从机的数据。 MOSI 与 MISO 的信号只在 NSS 为低电平的时候才有效，在 SCK 的每个时钟周期 MOSI 和 MISO 传输一位数据。以上通讯流程中包含的各个信号分解如下：</p>
<h2 id="通讯的起始和停止信号"><a href="#通讯的起始和停止信号" class="headerlink" title="通讯的起始和停止信号"></a>通讯的起始和停止信号</h2><p>标号①处， nSS信号由高电平变为低电平即为SPI通讯的起始信号，反过来，nSS信号由低电平变为高电平即为SPI通讯的结束信号。这个可比I2C简单得多了。当从机检测到自身的nSS引脚被拉低时就知道自己被主机选中，准备和主机进行通讯</p>
<h2 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h2><p>SPI 使用 MOSI 及 MISO 信号线来传输数据，使用 SCK 信号线进行数据同步。 MOSI 及MISO 数据线在 SCK 的每个时钟周期传输一位数据，且数据输入输出是同时进行的。数据传输时， MSB 先行或 LSB 先行并没有作硬性规定，但要保证两个 SPI 通讯设备之间使用同样的协定，一般都会采用图中的 MSB 先行模式。<br>观察图中的②③④⑤标号处， MOSI 及 MISO 的数据在 SCK 的上升沿期间变化输出，在SCK 的下降沿时被采样。即在 SCK 的下降沿时刻， MOSI 及 MISO 的数据有效，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效， MOSI及 MISO 为下一次表示数据做准备。<br>SPI 每次数据传输可以 8 位或 16 位为单位，每次传输的单位数不受限制。 </p>
<hr>
<p>这里需要再提及的概念是时钟极性(CPOL)和时钟相位(CPHA)。<br>  时钟极性(CPOL)指通讯设备处于空闲状态(SPI开始通讯前、nSS线无效)时，SCK的状态。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">CPOL</span> = <span class="number">0</span>：SCK在空闲时为低电平</span><br><span class="line"><span class="attr">CPOL</span> = <span class="number">1</span>：SCK在空闲时为高电平</span><br></pre></td></tr></table></figure>
<p>  时钟相位(CPHA)指数据的采样时刻位于SCK的偶数边沿采样还是奇数边沿采样。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">CPHA</span> = <span class="number">0</span>：在SCK的奇数边沿采样</span><br><span class="line"><span class="attr">CPHA</span> = <span class="number">1</span>：在SCK的偶数边沿采样</span><br></pre></td></tr></table></figure>
<p>  那么这样说来，<strong>*SPI的采样时刻并非由上升沿/下降沿决定的</strong>。注意的是，在数据采样时刻，MOSI和MOSI的电平为有效电平，数据不能在这个时刻进行切换注意的是，在数据采样时刻，MOSI和MOSI的电平为有效电平，数据不能在这个时刻进行切换。在非采样时刻MOSI和MISO上的信号才能切换</p>
<h1 id="编程要点"><a href="#编程要点" class="headerlink" title="编程要点"></a>编程要点</h1><p>(1) 初始化通讯使用的目标引脚及端口时钟；<br>(2) 使能 SPI 外设的时钟；<br>(3) 配置 SPI 外设的模式、地址、速率等参数并使能 SPI 外设；<br>(4) 编写基本 SPI 按字节收发的函数；<br>(5) 编写读写操作的的函数；<br>(6) 编写测试程序，对读写数据进行校验。 </p>
]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>CAN原理</title>
    <url>/2020/06/19/CAN/</url>
    <content><![CDATA[<p>CAN<br>CAN 通讯并不是以时钟信号来进行同步的，它是一种异步通讯， 只具有 CAN_High 和 CAN_Low 两条信号线，共同构成一组差分信号线，以差分信号的形式进行通讯。 由于 CAN 总线协议的物理层只有 1 对差分线，在一个时刻只能表示一个信号，所以对通讯节点来说， CAN 通讯是半双工的，收发数据需要分时进行。在 CAN 的通讯网络中，<strong><em>因为共用总线，在整个网络中同一时刻只能有一个通讯节点发送信号，其余的节点在该时刻都只能接收。</em></strong></p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="闭环总线网络"><a href="#闭环总线网络" class="headerlink" title="闭环总线网络"></a>闭环总线网络</h2><p>CAN 物理层的形式主要有两种， 图 42-1 中的 CAN 通讯网络是一种遵循 ISO11898 标准的高速、短距离“闭环网络”，它的总线最大长度为 40m，通信速度最高为 1Mbps，总线的两端各要求有一个“120 欧”的电阻。<br><img src="/images/14.png" alt=""> </p>
<a id="more"></a>
<h2 id="开环总线网络"><a href="#开环总线网络" class="headerlink" title="开环总线网络"></a>开环总线网络</h2><p>图为遵循 ISO11519-2 标准的低速、远距离“开环网络”，它的最大传输距<br>离为 1km，最高通讯速率为 125kbps，两根总线是独立的、不形成闭环，要求每根总线上各串联有一个“2.2 千欧”的电阻。<br><img src="/images/15.png" alt=""></p>
<h2 id="通讯节点"><a href="#通讯节点" class="headerlink" title="通讯节点"></a>通讯节点</h2><p>从 CAN 通讯网络图可了解到， CAN 总线上可以挂载多个通讯节点，节点之间的信号经过总线传输，实现节点间通讯。由于 CAN 通讯协议不对节点进行地址编码，而是对数据内容进行编码的，所以网络中的节点个数理论上不受限制，只要总线的负载足够即可，可以通过中继器增强负载。<br>CAN 通讯节点由一个 CAN 控制器及 CAN 收发器组成，控制器与收发器之间通过CAN_Tx 及 CAN_Rx 信号线相连，收发器与 CAN 总线之间使用 CAN_High 及 CAN_Low信号线相连。其中 CAN_Tx 及 CAN_Rx 使用普通的类似 TTL 逻辑信号，而 CAN_High 及CAN_Low 是一对差分信号线。</p>
<hr>
<h3 id="收发器和控制器的作用"><a href="#收发器和控制器的作用" class="headerlink" title="收发器和控制器的作用"></a>收发器和控制器的作用</h3><p>当 CAN 节点需要发送数据时， 控制器把要发送的二进制编码通过 CAN_Tx 线发送到收发器，然后由收发器把这个普通的逻辑电平信号转化成差分信号，通过差分线CAN_High 和 CAN_Low 线输出到 CAN 总线网络。而通过收发器接收总线上的数据到控制器时，则是相反的过程，收发器把总线上收到的 CAN_High 及 CAN_Low 信号转化成普通的逻辑电平信号，通过 CAN_Rx 输出到控制器中。<br>例如， STM32 的 CAN 片上外设就是通讯节点中的控制器，为了构成完整的节点，还<br>要给它外接一个收发器，使用型号为 TJA1050 的芯片作为 CAN 收发器。CAN 控制器与 CAN 收发器的关系如同 TTL 串口与 MAX3232 电平转换芯片的关系，MAX3232 芯片把 TTL 电平的串口信号转换成 RS-232 电平的串口信号， CAN 收发器的作用则是把 CAN 控制器的 TTL 电平信号转换成差分信号(或者相反)。 </p>
<hr>
<h3 id="差分信号"><a href="#差分信号" class="headerlink" title="差分信号"></a>差分信号</h3><p>差分信号又称差模信号，与传统使用单根信号线电压表示逻辑的方式有区别，使用差<br>分信号传输时，需要两根信号线，这两个信号线的振幅相等，相位相反，通过两根信号线的电压差值来表示逻辑 0 和逻辑 1。<br>我们用一个方法对差分信号做一下比喻，差分信号就好比是跷跷板上的两个人，当一个人被跷上去的时候，另一个人被跷下来了 - 但是他们的平均位置是不变的。继续跷跷板的类推，正值可以表示左边的人比右边的人高，而负值表示右边的人比左边的人高。0 表示两个人都是同一水平。<br><img src="/images/16.png" alt=""></p>
<p>相对于单信号线传输的方式，使用差分信号传输具有如下优点：<br>*抗干扰能力强，当外界存在噪声干扰时，几乎会同时耦合到两条信号线上，而接<br>收端只关心两个信号的差值，所以外界的共模噪声可以被完全抵消。</p>
<ul>
<li>能有效抑制它对外部的电磁干扰，同样的道理，由于两根信号的极性相反，他们<br>对外辐射的电磁场可以相互抵消，耦合的越紧密，泄放到外界的电磁能量越少。</li>
<li>时序定位精确，由于差分信号的开关变化是位于两个信号的交点，而不像普通单<br>端信号依靠高低两个阈值电压判断，因而受工艺，温度的影响小，能降低时序上<br>的误差，同时也更适合于低幅度信号的电路。 </li>
</ul>
<h4 id="CAN-协议中的差分信号"><a href="#CAN-协议中的差分信号" class="headerlink" title="CAN 协议中的差分信号"></a>CAN 协议中的差分信号</h4><p>CAN 协议中对它使用的 CAN_High 及 CAN_Low 表示的差分信号做了规定，。以高速 CAN 协议为例，当表示逻辑 1 时(隐性电平)， CAN_High 和 CAN_Low线上的电压均为 2.5v，即它们的电压差 VH-VL=0V；而表示逻辑 0 时(显性电平)，CAN_High 的电平为 3.5V， CAN_Low 线的电平为 1.5V，即它们的电压差为 VH-VL=2V。例如，当 CAN 收发器从 CAN_Tx 线接收到来自 CAN 控制器的低电平信号时(逻辑 0)，它会使 CAN_High 输出 3.5V，同时 CAN_Low 输出 1.5V，从而输出显性电平表示逻辑 0。<br><img src="/images/17.png" alt=""><br><img src="/images/18.png" alt=""></p>
<p><strong>* 在 CAN 总线中，必须使它处于隐性电平(逻辑 1)或显性电平(逻辑 0)中的其中一个状态。假如有两个 CAN 通讯节点，在同一时间，一个输出隐性电平，另一个输出显性电平，类似 I2C 总线的“线与”特性将使它处于显性电平状态，显性电平的名字就是这样来的， 即可以认为显性具有优先的意味.*</strong></p>
<hr>
<h1 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h1><p>什么是报文;CAN 使用的是两条差分信号线，只能表达一个信号，简洁的物理层决定了 CAN 必然要配上一套更复杂的协议，如何用一个信号通道实现同样、甚至更强大的功能呢？ CAN协议给出的解决方案是对数据、操作命令(如读/写)以及同步信号进行打包，打包后的这些内容称为报文。 </p>
<p>为了更有效地控制通讯， CAN 一共规定了 5 种类型的帧:<br>数据帧、要控帧、错误帧、过载帧、帧间隔</p>
<h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><p><img src="/images/19.png" alt=""></p>
<ul>
<li><p>帧起始<br>帧起始，也叫SOF。它用显性位表示，也就是0；它告诉我们，两个线上有电压差了，也就是有数据了。这个帧起始看起来只有一位，其实不简单了。为了让所有的分站都同步于发送报文的发送站，好接收数据，有很多要考虑的地方。</p>
</li>
<li><p>仲裁场<br>这个仲裁很抽象，其实在这里就是为了解决一个问题。如果2 个或2 个以上的单元同时开始传送报文，那么就会有总线访问冲突，那么仲裁机制就是用来根据标识符优先级来一个一个的去掉低级别的数据。我们可以详细的描述这场生动的争抢总线的战斗。当总线处于空闲状态时呈隐性电平，此时任何节点都可以向总线发送显性电平作为帧的开始。2 个或2 个以上的节点同时发送开始争抢总线，但是总线只能被一个人抢走。这时候到底怎么决定谁留下，谁滚蛋呢。我们开始思索，我们以前定义了标识符，标识符有优先级，它越小，它优先级越高。</p>
</li>
<li><p>控制段<br>在控制段中的 r1 和 r0 为保留位，默认设置为显性位。它最主要的是 DLC 段(DataLength Code)，译为数据长度码，它由 4 个数据位组成，用于表示本报文中的数据段含有多少个字节， DLC 段表示的数字为 0~8。</p>
</li>
<li><p>数据段<br>数据段为数据帧的核心内容，它是节点要发送的原始信息，由 0~8 个字节组成， MSB先行。</p>
</li>
<li><p>CRC 段<br>为了保证报文的正确传输， CAN 的报文包含了一段 15 位的 CRC 校验码，一旦接收节点算出的 CRC 码跟接收到的 CRC 码不同， 则它会向发送节点反馈出错信息，利用错误帧请求它重新发送。 CRC 部分的计算一般由 CAN 控制器硬件完成，出错时的处理则由软件控制最大重发数。在 CRC 校验码之后，有一个 CRC 界定符，它为隐性位，主要作用是把 CRC 校验码与后面的 ACK 段间隔起来。</p>
</li>
<li><p>ACK 段<br>ACK 段包括一个 ACK 槽位，和 ACK 界定符位。类似 I2C 总线，在 ACK 槽位中，发送节点发送的是隐性位，而接收节点则在这一位中发送显性位以示应答。在 ACK 槽和帧结束之间由 ACK 界定符间隔开。</p>
</li>
<li><p>帧结束<br>EOF 段(End Of Frame)，译为帧结束，帧结束段由发送节点发送的 7 个隐性位表示结束。 </p>
</li>
</ul>
<h2 id="远程帧："><a href="#远程帧：" class="headerlink" title="远程帧："></a>远程帧：</h2><p>通过发送远程帧，作为数据接收器的节点可以发起各自数据源的数据传送请求，即向数据发送器请求发送具有相同ID的数据帧。远程帧没有数据段。<br><img src="/images/20.png" alt=""></p>
<h2 id="错误帧："><a href="#错误帧：" class="headerlink" title="错误帧："></a>错误帧：</h2><p>错误类型：应答错误，填充错误，CRC错误，格式错误<br>错误帧由错误标志的叠加和结束符组成。错误标志有主动（积极）错误标志和被动（消极）错误标志。主动（积极）错误标志为6个显性位，被动（消极）错误标志为6个隐性位。<br>错误积极节点：如果检测到一个错误条件，就会发送积极错误标志。这将引起其它节点检测到填充错误，并开始发送错误标志。因此错误标志叠加在6~12位之间。节点发送完错误标志之后就发送一个隐性位，并监控总线，直到总线上出现一个隐性位，然后再发送7个隐性位。这样一个错误帧就发送完毕了。<br>消极错误节点：如果检测到一个错误条件，会试图发送一个消极错误标志进行指示。这个消极错误节点会一直等待6个具有相同极性的连续位，等待从消极错误标志起始开始，当检测到6个相同极性的连续位时，消极错误标志发送完成。<br><img src="/images/21.png" alt=""></p>
<h2 id="过载帧："><a href="#过载帧：" class="headerlink" title="过载帧："></a>过载帧：</h2><p>过载条件：接收器要求延迟下一次数据帧或远程帧的到达；在帧间隔间歇场的第一位和第二位检测到显性位；如果CAN节点在错误界定符或过载界定符的第8位采样到一个显性位，则节点会发送一个过载帧，错误计数器不会增加。<br><img src="/images/22.png" alt=""></p>
<h2 id="帧间空间："><a href="#帧间空间：" class="headerlink" title="帧间空间："></a>帧间空间：</h2><p>数据帧和远程帧的前面必然有帧间空间。对于主动错误节点和被动错误节点，帧间空间的结构稍有不同。对于主动错误节点，帧空间由3个显性位的间歇字段和总线空闲组成。在间歇字段不允许发送数据帧和远程帧。总线空闲的长度任意，当有显性位时就被认为是帧起始。被动错误标志除了上边两部分外，在间歇字段后还有8个显性位的挂起传输。在挂起传输阶段被动错误节点不可以发送数据帧与远程帧。<br><img src="/images/23.png" alt=""></p>
<h1 id="MCU-CAN数据流向分析"><a href="#MCU-CAN数据流向分析" class="headerlink" title="MCU-CAN数据流向分析"></a>MCU-CAN数据流向分析</h1><p>1、记录仪CAN收发器接收到数据首先送入过滤器（CAN收发器有28组过滤器，每组包含2个32位寄存器，可以设置成2个CAN ID或掩码后的一组CAN ID，一般情况当采集CAN ID超出56时，将采用掩码方式。目前记录仪已经最多采集300多个CAN ID，已经无法精准过滤）；<br>2、经过滤器（过滤掉一部分CAN ID）送入预置的一个FIFO（一路CAN自带2个FIFO缓冲区，可分别缓存一帧完整报文）；<br>3、当缓存一帧完整报文后，FIFO将产生一个中断（实测亚毫秒级）报告给MCU，通过MCU中断程序将FIFO中的CAN报文转存至用户RAM。MCU处理中断的能力在微秒级，足以保证，在FIFO环节数据不丢失。<br>4、用户RAM（256B或根据压力测试自由分配）当前可以缓存20组CANID 及数据。用户进程（时间片1ms）有充足的时间将RAM中缓存的CAN数据交给用户程序处理，保证在应用环节数据不丢失。<br><img src="/images/24.png" alt=""><br><img src="/images/25.png" alt=""></p>
]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>CAN</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言中对可变参数列表的简单理解</title>
    <url>/2020/06/12/c%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E6%95%B0%E7%9B%AE%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>C中变长实参头文件stdarg.h提供了一个数据类型va-list和三个宏（va-start、va-arg和va-end），用它们在被调用函数不知道参数个数和类型时对可变参数表进行测试，从而为访问可变参数提供了方便且有效的方法。va-list是一个char类型的指针，当被调用函数使用一个可变参数时，它声明一个类型为va-list的变量，该变量用来指向va-arg和va-end所需信息的位置。下面给出va_list、va-start、va-arg和va-end在C中的源码：<br><code>typedef char *  va_list;</code><br><code>#define va_start(ap,v)  ( ap = (va_list)&amp;v + _INTSIZEOF(v) )   //得到可变参数中第一个参数的首地址</code><br><code>#define va_arg(ap,type)    ( *(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)) )    //将参数转换成需要的类型，并使ap指向下一个参数</code><br><code>#define va_end(ap)      ( ap = (va_list)0 )//功能就是把指针ap赋值为0，使它不指向内存的变量</code></p>
<a id="more"></a>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> <span class="comment">/*函数sum中首先定义了可变参数表指针vap，而后通过va_start ( vap, n )取得了参数表首地址（赋值给了vap），</span></span><br><span class="line"><span class="comment"> 其后的for循环则用来遍历可变参数表。*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i , sum = <span class="number">0</span>;</span><br><span class="line">	va_list vap;  <span class="comment">//声明va_list变量</span></span><br><span class="line">	va_start(vap , n);     <span class="comment">//指向可变参数表中的第一个参数</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; ++i)</span><br><span class="line">		sum += va_arg(vap , <span class="keyword">int</span>);     <span class="comment">//取出可变参数表中的参数，并修改参数指针vap使其增加以指向表中下一个参数</span></span><br><span class="line">	va_end(vap);    <span class="comment">//把指针vap赋值为0</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = sum(<span class="number">3</span> , <span class="number">45</span> , <span class="number">89</span> , <span class="number">72</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数原型声明，至少需要一个确定的参数，注意括号内的省略号</li>
<li>在调用参数表之前，定义一个 va_list 类型的变量，(假设va_list 类型变量被定义为ap)；</li>
<li>然后应该对ap进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“…”之前的那个参数；</li>
<li>然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把ap的位置指向变参表的下一个变量位置；</li>
<li>获取所有的参数之后，我们有必要将这个ap指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数ap置为NULL，应该养成获取完参数表之后关闭指针的习惯。通常va_start和va_end是成对出现。<strong>va-end必须在va-arg读完所有参数后再调用</strong></li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>gbd调试</title>
    <url>/2020/06/25/gdb/</url>
    <content><![CDATA[<p>使用gdb时遇到这个问题，刚开始接触linux下使用gdb调试程序，其原因是生成的二进制可执行文件没有使用-g选项。<br>gcc中-g选项是为了获得有关调试信息，要用gdb进行调试，必须使用-g生成二进制可执行文件，<br><code>gcc -g example.c -o example</code></p>
<h1 id="查找段错误"><a href="#查找段错误" class="headerlink" title="查找段错误"></a>查找段错误</h1><p>gcc -g获取调试信息后直接run，程序到哪里停就是哪里发生了段错误</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>lua函数</title>
    <url>/2020/06/12/Lua%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>函数定义</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">optional_function_scope <span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">( argument1, argument2, argument3<span class="rest_arg">..., argumentn</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">function_body</span></span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">result_params_comma_separated</span></span></span><br><span class="line"><span class="function"><span class="title">end</span></span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>解析：</p>
<ul>
<li>optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。</li>
<li>function_name: 指定函数名称。</li>
<li>argument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。</li>
<li>function_body: 函数体，函数中需要执行的代码语句块。</li>
<li>result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。</li>
</ul>
<hr>
<h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p>Lua函数可以返回多个结果值，在return后列出要返回的值的列表即可返回多值</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maximum</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">local</span> mi = <span class="number">1</span>             <span class="comment">-- 最大值索引</span></span><br><span class="line">    <span class="keyword">local</span> m = a[mi]          <span class="comment">-- 最大值</span></span><br><span class="line">    <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">       <span class="keyword">if</span> val &gt; m <span class="keyword">then</span></span><br><span class="line">           mi = i</span><br><span class="line">           m = val</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> m, mi</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(maximum(&#123;<span class="number">8</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">5</span>&#125;))</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="number">23</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 … 表示函数有可变的参数</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">function add(...)  </span><br><span class="line">local s = <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">for</span> i, v <span class="keyword">in</span> ipairs<span class="meta">&#123;...&#125;</span> <span class="keyword">do</span>   --&gt; <span class="meta">&#123;...&#125;</span> 表示一个由所有变长参数构成的数组  </span><br><span class="line">    s = s + v  </span><br><span class="line">  <span class="keyword">end</span>  </span><br><span class="line">  <span class="keyword">return</span> s  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line">print(add(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>))  ---&gt;<span class="number">25</span></span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">function average(...)</span><br><span class="line">   <span class="literal">result</span> = <span class="number">0</span></span><br><span class="line">   local arg=<span class="meta">&#123;...&#125;</span>    --&gt; arg 为一个表，局部变量</span><br><span class="line">   <span class="keyword">for</span> i,v <span class="keyword">in</span> ipairs(arg) <span class="keyword">do</span></span><br><span class="line">      <span class="literal">result</span> = <span class="literal">result</span> + v</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   print(<span class="string">"总共传入 "</span> .. <span class="comment">#arg .. " 个数")</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">result</span>/<span class="comment">#arg</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"平均值为"</span>,average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>


<p>有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fwrite</span><span class="params">(fmt, ...)</span></span>  <span class="comment">---&gt; 固定的参数fmt</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt, ...))    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fwrite(<span class="string">"runoob\n"</span>)       <span class="comment">---&gt;fmt = "runoob", 没有变长参数。  </span></span><br><span class="line">fwrite(<span class="string">"%d%d\n"</span>, <span class="number">1</span>, <span class="number">2</span>)   <span class="comment">---&gt;fmt = "%d%d", 变长参数为 1 和 2</span></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">runoob</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>通常在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select(‘#’, …) 或者 select(n, …)</p>
<p>select(‘#’, …) 返回可变参数的长度<br>select(n, …) 用于返回 n 到 select(‘#’,…) 的参数</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(<span class="rest_arg">...)  </span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="rest_arg">        for</span> i = 1, select(<span class="string">'#'</span>, <span class="rest_arg">...) do</span>  --&gt;获取参数总数</span></span></span><br><span class="line"><span class="function"><span class="params">            local arg = select(i, <span class="rest_arg">...); --&gt;读取参数</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="rest_arg">            print</span>(<span class="string">"arg"</span>, arg)</span></span>;  </span><br><span class="line">        end  </span><br><span class="line">    end  </span><br><span class="line"> </span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>UART原理</title>
    <url>/2020/06/19/UART/</url>
    <content><![CDATA[<p>优点：</p>
<ul>
<li>只使用两根电线</li>
<li>支持多个主服务器和多个从服务器</li>
<li>ACK / NACK位确认每个帧都已成功传输</li>
<li>硬件没有UART那么复杂</li>
<li>众所周知且广泛使用的协议</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据传输速率比SPI慢</li>
<li>数据帧的大小限制为8位</li>
<li>实现比SPI更复杂的硬件</li>
</ul>
<h1 id="异步通信与同步通信区别"><a href="#异步通信与同步通信区别" class="headerlink" title="异步通信与同步通信区别"></a>异步通信与同步通信区别</h1><h2 id="异步通信："><a href="#异步通信：" class="headerlink" title="异步通信："></a>异步通信：</h2><p>异步通信中的接收方并不知道数据什么时候会到达，收发双方可以有各自自己的时钟。发送方发送的时间间隔可以不均，接收方是在数据的起始位和停止位的帮助下实现信息同步的。这种传输通常是很小的分组，比如一个字符为一组，为这个组配备起始位和结束位。所以这种传输方式的效率是比较低的，毕竟额外加入了很多的辅助位作为负载，常用在低速的传输中。<br>举个例子，我们的键盘按下一个按键，发出一个字符信号，异步传输机制就会为它加上前后的辅助同步信息，帮助接收方识别到我们按下了哪一个按键。因为我们敲击键盘的节奏不固定，所以异步是一种很适合的方式。</p>
<a id="more"></a>

<h2 id="同步通信："><a href="#同步通信：" class="headerlink" title="同步通信："></a>同步通信：</h2><p>  同步通信中双方使用频率一致的时钟，它的分组相比异步则大得多，称为一个数据帧，通过独特的bit串作为启停标识。发送方要以固定的节奏去发送数据，而接收方要时刻做好接收数据的准备，识别到前导码后马上要开始接收数据了。同步这种方式中因为分组很大，很长一段数据才会有额外的辅助位负载，所以效率更高，更加适合对速度要求高的传输，当然这种通信对时序的要求也更高。</p>
<hr>
<p>总结一下，异步传输其实是通过字符数据前后的开始和停止码进行再同步，弥补自己刚才注意不集中的不足；而同步方式则是一个规矩的好学生，时刻候命准备工作。异步是你扔出去一个内容，对方靠着内容前后他能嗅到的异样在人潮之中发现了它，把这个内容存下来；而同步是对方在时刻等着你发布号令，你告诉对方我要发送了哦，然后双方一拍即合。</p>
<h1 id="USART和UART区别"><a href="#USART和UART区别" class="headerlink" title="USART和UART区别"></a>USART和UART区别</h1><p>UART它是在 USART 基础上裁剪掉了同步通信功能，只有异步通信。 简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是UART。</p>
<h1 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h1><h2 id="串口数据包的基本组成"><a href="#串口数据包的基本组成" class="headerlink" title="串口数据包的基本组成"></a>串口数据包的基本组成</h2><p><img src="/images/10.png" alt=""></p>
<h2 id="原理理解"><a href="#原理理解" class="headerlink" title="原理理解"></a>原理理解</h2><p>也就是双方必要约定一种暗号。<br>也许当时发送这个通信的小组是这样讨论的。<br>经理：我要用一根线就能传输数据，你来给我定个标准。<br>研发：好。<br>经理：只有一根线，我怎么知道数据什么时候开始呢。<br>研发：就一根线，默认是高电平，那就有一个起始位吧。当检测到有低电平的时候，就是开始有一个字节的数据发送了,起始位之后，先是字节的最低位,传送一个字节。<br>经理：可是，就一根线，过来的数据会不会有干扰，容易出错呀。<br>研发：行呀，那就在字节数据后再加一个校验位。可以作奇校验，偶校验，1校验，0校验，无校验。<br>经理：嗯 ，很不错。有起始位就应该有停止位，那我们就再加个停止位在后面吧。<br>经理：传输一串数据，对方要怎么知道数据的拆分呢，怎么按时间或频率去解读数据位，校验位呢。<br>研发：这样吧，双方约定一个波特率吧，定义一个每个位占用多长的时间，这样双方按这个波特率就可以处理了。这个波特率呢，是指1S钟可以传输多个位，也就知道一个位占用多长时间。这样就解决传输的问题了。（波特率：即单位时间内传输的符号个数；）<br>经理：那万一传输过程，数据快太，判断失误停不下来怎么办。<br>研发：那就把停止位可以调节为1个停止位或者2个停止位。这样就可以停下来了。<br>经理：嗯，听着不错。就这样办吧。</p>
<p>于是，串口通信就这样出来了。<br>在串口的通信参数上，就有了波特率，数据位，停止位，校验位这几个参数来确保串口通信的正确性和稳定上。当然，这只是某个方面保证串口通信的正确性和稳定性，不代表设备间通信的正确性和稳定性。</p>
<h3 id="1-波特率"><a href="#1-波特率" class="headerlink" title="1. 波特率"></a>1. 波特率</h3><p>异步通讯中由于没有时钟信号接口中是没有时钟信号的)，所以两个通讯设备之间需要约定好波特率，即每个码元的长度。常见的波特率为4800、 9600、 115200 等。波特率：即单位时间内传输的符号个数。</p>
<h3 id="2-通讯的起始和停止信号"><a href="#2-通讯的起始和停止信号" class="headerlink" title="2. 通讯的起始和停止信号"></a>2. 通讯的起始和停止信号</h3><p>串口通讯的一个数据包从起始信号开始，直到停止信号结束。数据包的起始信号由一个逻辑 0 的数据位表示，而数据包的停止信号可由 0.5、 1、 1.5 或 2 个逻辑 1 的数据位表示，只要双方约定一致即可。</p>
<h3 id="3-有效数据"><a href="#3-有效数据" class="headerlink" title="3. 有效数据"></a>3. 有效数据</h3><p>在数据包的起始位之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度常被约定为 5、 6、 7 或 8 位长。</p>
<h3 id="4-数据校验"><a href="#4-数据校验" class="headerlink" title="4. 数据校验"></a>4. 数据校验</h3><p>在有效数据之后，有一个可选的数据校验位。由于数据通信相对更容易受到外部干扰导致传输数据出现偏差，可以在传输过程加上校验位来解决这个问题。校验方法有奇校验(odd)、偶校验(even)、 0 校验(space)、 1 校验(mark)以及无校验(noparity)。奇校验要求有效数据和校验位中“1”的个数为奇数，比如一个 8 位长的有效数据为：01101001，此时总共有4个“1”，为达到奇校验效果，校验位为“1”，最后传输的数据将是 8 位的有效数据加上 1 位的校验位总共 9 位。偶校验与奇校验要求刚好相反，要求帧数据和校验位中“1”的个数为偶数，比如数据帧： 11001010，此时数据帧“1”的个数为 4 个，所以偶校验位为“0”。0校验是不管有效数据中的内容是什么，校验位总为“0”， 1 校验是校验位总为“1”。</p>
<hr>
<p>在两个UART之间传输数据只需要两根线。数据从发送UART的Tx引脚流向接收UART的Rx引脚：<br><img src="/images/11.png" alt=""></p>
<h1 id="编程要点"><a href="#编程要点" class="headerlink" title="编程要点"></a>编程要点</h1><ol>
<li>使能 RX 和 TX 引脚 GPIO 时钟和 USART 时钟；</li>
<li>初始化 GPIO，并将 GPIO 复用到 USART 上；</li>
<li>配置 USART 参数；</li>
<li>配置中断控制器并使能 USART 接收中断；</li>
<li>使能 USART；</li>
<li>在 USART 接收中断服务函数实现数据接收和发送。</li>
</ol>
]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>UART</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua循环</title>
    <url>/2020/06/11/lua%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><h2 id="数值for循环"><a href="#数值for循环" class="headerlink" title="数值for循环"></a>数值for循环</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var=<span class="built_in">exp1</span>,<span class="built_in">exp2</span>,exp3 <span class="built_in">do</span>  </span><br><span class="line">    &lt;执行体&gt;  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 “执行体”。exp3 是可选的，如果不指定，<strong>默认为1。</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"function"</span>)  </span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,f(<span class="number">5</span>) <span class="keyword">do</span> <span class="built_in">print</span>(i)  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>for的三个表达式在循环开始前一次性求值，以后不再进行求值。比如上面的f(x)只会在循环开始前执行一次，其结果用在后面的循环中。</p>
<a id="more"></a>

<p>验证如下:<br>执行结果：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">function</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型for循环"><a href="#泛型for循环" class="headerlink" title="泛型for循环"></a>泛型for循环</h2><p>泛型 for 循环通过一个迭代器函数来遍历所有值，类似 java 中的 foreach 语句。<br>Lua 编程语言中泛型 for 循环语法格式:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>i是数组索引值，v是对应索引的数组元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组。<br>执行结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>one</span><br><span class="line"><span class="symbol">2 </span>two</span><br><span class="line"><span class="symbol">3 </span>three</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">statements</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>statements(循环体语句) 可以是一条或多条语句，condition(条件) 可以是任意表达式，在 condition(条件) 为 true 时执行循环体语句。</p>
<hr>
<h1 id="repeat…until-循环"><a href="#repeat…until-循环" class="headerlink" title="repeat…until 循环"></a>repeat…until 循环</h1><p> repeat…until 循环语句不同于 for 和 while循环，for 和 while 循环的条件语句在当前循环执行开始时判断，而 repeat…until 循环的条件语句在当前循环结束后判断<br> <figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"> repeat</span><br><span class="line">   <span class="built_in">statements</span></span><br><span class="line"><span class="keyword">until</span>( condition )</span><br></pre></td></tr></table></figure><br>循环条件判断语句（condition）在循环体末尾部分，所以在条件进行判断前循环体都会执行一次。<strong>如果条件判断语句（condition）为 false，循环会重新开始执行，直到条件判断语句（condition）为 true 才会停止执行。</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">a</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">--[ 执行循环 --]</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   print(<span class="string">"a的值为:"</span>, <span class="keyword">a</span>)</span><br><span class="line">   <span class="keyword">a</span> = <span class="keyword">a</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span>( <span class="keyword">a</span> &gt; <span class="number">15</span> )</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">a的值为:    <span class="number">10</span></span><br><span class="line">a的值为:    <span class="number">11</span></span><br><span class="line">a的值为:    <span class="number">12</span></span><br><span class="line">a的值为:    <span class="number">13</span></span><br><span class="line">a的值为:    <span class="number">14</span></span><br><span class="line">a的值为:    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h1><p>语法格式如下所示<br><code>goto Label</code><br>Label 的格式为：<br><code>:: Label ::</code></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">local a = 1</span><br><span class="line"><span class="meta">::label::</span> print("--- goto label ---")</span><br><span class="line"></span><br><span class="line">a = a+1</span><br><span class="line">if a &lt; 3 then</span><br><span class="line"><span class="code">    goto label   -- a 小于 3 的时候跳转到标签 label</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">--<span class="literal">-</span> <span class="comment">goto</span> <span class="comment">label</span> --<span class="literal">-</span></span><br><span class="line">--<span class="literal">-</span> <span class="comment">goto</span> <span class="comment">label</span> --<span class="literal">-</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="variable">then</span></span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="string">"0 为 true"</span>)</span></span><br><span class="line"><span class="variable">end</span></span><br></pre></td></tr></table></figure>

<p>if else</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(布尔表达式)</span></span><br><span class="line"><span class="variable">then</span></span><br><span class="line">   --[ 布尔表达式为 <span class="variable"><span class="literal">true</span></span> 时执行该语句块 --]</span><br><span class="line"><span class="variable"><span class="keyword">else</span></span></span><br><span class="line">   --[ 布尔表达式为 <span class="variable"><span class="literal">false</span></span> 时执行该语句块 --]</span><br><span class="line"><span class="variable">end</span></span><br></pre></td></tr></table></figure>

<p>if…elesif…else</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">if(</span> <span class="string">布尔表达式</span> <span class="number">1</span><span class="string">)</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line">   <span class="string">--[</span> <span class="string">在布尔表达式</span> <span class="number">1</span> <span class="string">为</span> <span class="literal">true</span> <span class="string">时执行该语句块</span> <span class="string">--]</span></span><br><span class="line"></span><br><span class="line"><span class="string">elseif(</span> <span class="string">布尔表达式</span> <span class="number">2</span><span class="string">)</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line">   <span class="string">--[</span> <span class="string">在布尔表达式</span> <span class="number">2</span> <span class="string">为</span> <span class="literal">true</span> <span class="string">时执行该语句块</span> <span class="string">--]</span></span><br><span class="line"></span><br><span class="line"><span class="string">elseif(</span> <span class="string">布尔表达式</span> <span class="number">3</span><span class="string">)</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line">   <span class="string">--[</span> <span class="string">在布尔表达式</span> <span class="number">3</span> <span class="string">为</span> <span class="literal">true</span> <span class="string">时执行该语句块</span> <span class="string">--]</span></span><br><span class="line"><span class="string">else</span> </span><br><span class="line">   <span class="string">--[</span> <span class="string">如果以上布尔表达式都不为</span> <span class="literal">true</span> <span class="string">则执行该语句块</span> <span class="string">--]</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2020/06/10/hello-world/</url>
    <content><![CDATA[<h1 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h1><p>在source/_posts 文件夹下创建.md文件<br>配置属性</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Markdown基本语法</span></span><br><span class="line"><span class="attr">data:</span> <span class="number">2019</span><span class="number">-6</span><span class="number">-10</span></span><br><span class="line"><span class="attr">categories:</span>    </span><br><span class="line"><span class="bullet">-</span> <span class="string">lua语言</span>    <span class="comment">##添加到lua语言分类，也也可以新建一个分类</span></span><br><span class="line"><span class="string">tags：</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">lua</span>        <span class="comment">#添加标签</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">编程</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>文章写完回到终端 hexo g 再 hexo d</p>
<a id="more"></a>

<p>在写博客的时候在文章中使用&lt;!--more--&gt;进行手动截断,这样可以实现只显示摘要的效果，并且在摘要下方生成一个阅读全文的链接</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>Markdown 是一种标记语言，语法简单，易阅读易编写，可以让用户完全脱离鼠标写出样式丰富的文档，广受程序员喜爱，目前许多网站都已经支持通过 Markdown 语法来写文章或者发表评论。 </p>
<h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<h2 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h2><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="strong">*这是斜体*</span> 或 <span class="emphasis">_这也是斜体_</span> </span><br><span class="line">*<span class="strong">*这是粗体*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">*</span>*<span class="strong">*这是加粗斜体*</span>*<span class="strong">*</span></span><br><span class="line"><span class="strong">~~这是删除线~~</span></span><br></pre></td></tr></table></figure>
<p>效果：<br><em>这是斜体</em> 或 <em>这也是斜体</em><br><strong>这是粗体</strong><br><strong><em>这是加粗斜体</em></strong><br><del>这是删除线</del> </p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">|<span class="string"> 表头1</span>|<span class="string">表头2</span>|<span class="string">表头3</span>|<span class="string">表头4</span></span><br><span class="line">|<span class="string">-</span>|<span class="string"> :- </span>|<span class="string"> :-: </span>|<span class="string"> -: </span>|</span><br><span class="line">|<span class="string">默认左对齐</span>|<span class="string">左对齐</span>|<span class="string">居中对其</span>|<span class="string">右对齐</span>|</span><br><span class="line">|<span class="string">默认左对齐</span>|<span class="string">左对齐</span>|<span class="string">居中对其</span>|<span class="string">右对齐</span>|</span><br><span class="line">|<span class="string">默认左对齐</span>|<span class="string">左对齐</span>|<span class="string">居中对其</span>|<span class="string">右对齐</span>|</span><br></pre></td></tr></table></figure>
<p>效果：（表格与文字要有空行）</p>
<table>
<thead>
<tr>
<th>表头1</th>
<th align="left">表头2</th>
<th align="center">表头3</th>
<th align="right">表头4</th>
</tr>
</thead>
<tbody><tr>
<td>默认左对齐</td>
<td align="left">左对齐</td>
<td align="center">居中对其</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td>默认左对齐</td>
<td align="left">左对齐</td>
<td align="center">居中对其</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td>默认左对齐</td>
<td align="left">左对齐</td>
<td align="center">居中对其</td>
<td align="right">右对齐</td>
</tr>
</tbody></table>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">```代码块```  #单行代码一个点包起来</span><br></pre></td></tr></table></figure>


<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">comment</span>]: <span class="link">&lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="symbol">comment</span>]: <span class="link">&lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="symbol">comment</span>]: <span class="link">&lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="symbol">//</span>]: <span class="link">&lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</span></span><br><span class="line">[<span class="symbol">//</span>]: <span class="link"># (哈哈我是注释，不会在浏览器中显示。)</span></span><br></pre></td></tr></table></figure>



<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>Markdown中的转义字符为\，可以转义的有：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">\\</span> 反斜杠</span><br><span class="line"><span class="symbol">\`</span> 反引号</span><br><span class="line"><span class="symbol">\*</span> 星号</span><br><span class="line"><span class="symbol">\_</span> 下划线</span><br><span class="line"><span class="symbol">\&#123;</span><span class="symbol">\&#125;</span> 大括号</span><br><span class="line"><span class="symbol">\[</span><span class="symbol">\]</span> 中括号</span><br><span class="line"><span class="symbol">\(</span><span class="symbol">\)</span> 小括号</span><br><span class="line"><span class="symbol">\#</span> 井号</span><br><span class="line"><span class="symbol">\+</span> 加号</span><br><span class="line"><span class="symbol">\-</span> 减号</span><br><span class="line"><span class="symbol">\.</span> 英文句号</span><br><span class="line"><span class="symbol">\!</span> 感叹号</span><br><span class="line"><span class="symbol">\&lt;</span>&gt;尖括号</span><br></pre></td></tr></table></figure>


<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>在 Hexo 中插入图片，首先需要将图片放在 source/images/ 文件夹下，然后如下方式进行插入：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">!<span class="selector-attr">[]</span>(/images/insert_image.jpg)</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="/images/header.jpg" alt=""></p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内形式：[<span class="string">我的博客</span>](<span class="link">http://pixvc.github.io/</span>)</span><br><span class="line">参考形式：[<span class="string">p站</span>][<span class="symbol">1</span>]，[<span class="string">谷歌</span>][<span class="symbol">2</span>]</span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">https://cn.pornhub.com/</span></span><br><span class="line">[<span class="symbol">2</span>]:<span class="link">https://www.google.com/</span></span><br></pre></td></tr></table></figure>
<p>效果：<br>行内形式：<a href="http://pixvc.github.io/">我的博客</a><br>参考形式：[p站][1]，[谷歌][2]<br>[1]:<a href="https://cn.pornhub.com/" target="_blank" rel="noopener">https://cn.pornhub.com/</a><br>[2]:<a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a></p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">**<span class="strong">*</span></span><br><span class="line"><span class="strong">*</span>***<span class="strong">*</span></span><br></pre></td></tr></table></figure>
<h2 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h2><hr>
<hr>
<hr>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line"><span class="meta">&gt;&gt;</span>这是引用的内容</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>1.无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="bullet">* </span>第二项</span><br><span class="line"><span class="bullet">* </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>第一项</span><br><span class="line"><span class="bullet">+ </span>第二项</span><br><span class="line"><span class="bullet">+ </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>第一项</span><br><span class="line"><span class="bullet">- </span>第二项</span><br><span class="line"><span class="bullet">- </span>第三项</span><br></pre></td></tr></table></figure>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<p>2.有序列表使用数字并加上 . 号来表示，如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 第一项</span><br><span class="line"><span class="number">2.</span> 第二项</span><br><span class="line"><span class="number">3.</span> 第三项</span><br></pre></td></tr></table></figure>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<p>3.列表嵌套只需在子列表中的选项添加四个空格即可：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项：</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2. </span>第二项：</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>makedown</tag>
      </tags>
  </entry>
  <entry>
    <title>IIC原理</title>
    <url>/2020/06/19/IIC/</url>
    <content><![CDATA[<p><strong><em>STM32的硬件IIC非常复杂，更重要的是它并不稳定，故推荐使用软件模拟IIC</em></strong></p>
<hr>
<p>IIC优点：</p>
<ul>
<li>仅用两根线就完成了数据传输</li>
<li>采用器件地址的硬件设置方法，通过软件寻址避免了像SPI那样的器件片选线寻址，显著地简化了微控制器和外围器件之间的连接，连接在同一条总线上</li>
<li>要求被寻址的设备发回应答信息，这样可以提供相对可靠的系统</li>
</ul>
<p>IIC缺点：</p>
<ul>
<li>仅能实现半双工通信</li>
<li>传输速率也相对有限</li>
<li>易受干扰，并且不检查错误</li>
</ul>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p><img src="/images/1.png" alt=""></p>
<a id="more"></a>

<p>它的物理层有如下特点：</p>
<ol>
<li>它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线<br>中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。</li>
<li>一个 I2C 总线只使用两条总线线路，一条双向串行数据线(SDA) ，一条串行时钟线(SCL)。数据线即用来表示数据，时钟线用于数据收发同步。</li>
<li>每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。</li>
<li>总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。</li>
<li>多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</li>
<li>具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多 I2C 设备尚不支持高速模式。</li>
<li>连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制 。 </li>
</ol>
<h1 id="I2C-基本读写过程"><a href="#I2C-基本读写过程" class="headerlink" title="I2C 基本读写过程"></a>I2C 基本读写过程</h1><p><img src="/images/2.png" alt=""></p>
<h2 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h2><p>若配置的方向传输位为“写数据”方向， 即第一幅图的情况， 广播完地址，接收到应答信号后， 主机开始正式向从机传输数据(DATA)，数据包的大小为 8 位，主机每发送完一个字节数据，都要等待从机的应答信号(ACK)，重复这个过程，可以向从机传输 N 个数据，这个 N 没有大小限制。当数据传输结束时，主机向从机发送一个停止传输信号(P)，表示不再传输数据。</p>
<hr>
<h2 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h2><p>若配置的方向传输位为“读数据”方向， 即第二幅图的情况， 广播完地址，接收到应答信号后， 从机开始向主机返回数据(DATA)，数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号(ACK)，重复这个过程，可以返回 N 个数据，这个 N 也没有大小限制。当主机希望停止接收数据时，就向从机返回一个非应答信号(NACK)，则从机自动停止数据传输。</p>
<hr>
<h2 id="读和写数据"><a href="#读和写数据" class="headerlink" title="读和写数据"></a>读和写数据</h2><p>除了基本的读写， I2C 通讯更常用的是复合格式，即第三幅图的情况，该传输过程有两次起始信号(S)。一般在第一次传输中，主机通过 SLAVE_ADDRESS 寻找到从设备后，发送一段“数据”，这段数据通常用于表示从设备内部的寄存器或存储器地址(注意区分它与 SLAVE_ADDRESS 的区别)；在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。</p>
<h1 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h1><h2 id="起始和停止信号"><a href="#起始和停止信号" class="headerlink" title="起始和停止信号"></a>起始和停止信号</h2><p>起始(S)和停止(P)信号是两种特殊的状态。当 SCL 线是高电平时 SDA 线从高电平向低电平切换，这个情况表示通讯的起始。当 SCL 是高电平时 SDA线由低电平向高电平切换，表示通讯的停止。起始和停止信号一般由主机产生。<br><img src="/images/3.png" alt=""></p>
<h2 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h2><p>I2C 使用 SDA 信号线来传输数据，使用 SCL信号线进行数据同步。 SDA 数据线在 SCL的每个时钟周期传输一位数据。传输时， SCL为高电平的时候 SDA表示的数据有效，即此时的 SDA为高电平时表示数据“1”，为低电平时表示数据“0”。当 SCL为低电平时， SDA的数据无效，一般在这个时候 SDA 进行电平切换，为下一次表示数据做好准备。<br><img src="/images/4.png" alt=""><br><img src="/images/5.png" alt=""></p>
<p>##地址及数据方向<br>I2C 总线上的每个设备都有自己的独立地址，主机发起通讯时，通过 SDA 信号线发送<br>设备地址(SLAVE_ADDRESS)来查找从机。 I2C 协议规定设备地址可以是 7 位或 10 位，实际中 7 位的地址应用比较广泛。紧跟设备地址的一个数据位用来表示数据传输方向，它是数据方向位(R/W)，第 8 位或第 11 位。数据方向位为“1”时表示主机由从机读数据，该位为“0”时表示主机向从机写数据。<br><img src="/images/6.png" alt=""><br>读数据方向时，主机会释放对 SDA 信号线的控制，由从机控制 SDA 信号线，主机接收信号，写数据方向时， SDA 由主机控制，从机接收信号。</p>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>IIC总线协议规定，每传送一个字节数据<strong>(含地址及命令)</strong>后，都要有一个应答信号，以确定数据传送是否被对方收到。应答信号由接受设备产生，在SCL信号为高电平期间，接受设备将SDA拉为低电平，表示数据传送正确，产生应答。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。作为数据接收端时，当设备(无论主从机)接收到 I2C 传输的一个字节数据或地址后，若希望对方继续发送数据，则需要向对方发送“应答(ACK)”信号，发送方会继续发送下一个数据；若接收端希望结束数据传输，则向对方发送“非应答(NACK)”信号，发送方接收到该信号后会产生一个停止信号，结束信号传输<br><img src="/images/7.png" alt=""><br><img src="/images/8.png" alt=""><br><strong>*传输时主机产生时钟，在第 9 个时钟时，数据发送端会释放 SDA 的控制权，由数据接收端控制 SDA，若 SDA 为高电平，表示非应答信号(NACK)，低电平表示应答信号(ACK)。 *</strong><br><img src="/images/9.png" alt=""></p>
<h1 id="stm321编程要点"><a href="#stm321编程要点" class="headerlink" title="stm321编程要点"></a>stm321编程要点</h1><ol>
<li>配置通讯使用的目标引脚为开漏模式；</li>
<li>使能 I2C 外设的时钟；</li>
<li>配置 I2C 外设的模式、地址、速率等参数并使能 I2C 外设；</li>
<li>编写基本 I2C 按字节收发的函数；</li>
<li>编写读写内容的函数；</li>
<li>编写测试程序，对读写数据进行校验。 </li>
</ol>
<p>软件模拟IIC</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化IIC</span></span><br><span class="line"><span class="built_in">void</span> IIC_Init(<span class="built_in">void</span>)</span><br><span class="line">&#123;					     </span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	RCC_APB2PeriphClockCmd(	RCC_APB2Periph_GPIOB, ENABLE );	<span class="comment">//使能GPIOB时钟</span></span><br><span class="line">	   </span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP ;   <span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">	GPIO_SetBits(GPIOB,GPIO_Pin_6|GPIO_Pin_7); 	<span class="comment">//PB6,PB7 输出高，空闲状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产生IIC起始信号</span></span><br><span class="line"><span class="built_in">void</span> IIC_Start(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	SDA_OUT();     <span class="comment">//sda线输出</span></span><br><span class="line">	IIC_SDA=<span class="number">1</span>;	  	  </span><br><span class="line">	IIC_SCL=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">4</span>);</span><br><span class="line"> 	IIC_SDA=<span class="number">0</span>;    <span class="comment">//START:when CLK is high,DATA change form high to low </span></span><br><span class="line">	delay_us(<span class="number">4</span>);</span><br><span class="line">	IIC_SCL=<span class="number">0</span>;    <span class="comment">//钳住I2C总线，准备发送或接收数据 </span></span><br><span class="line">&#125;	  </span><br><span class="line"><span class="comment">//产生IIC停止信号</span></span><br><span class="line"><span class="built_in">void</span> IIC_Stop(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	SDA_OUT();    <span class="comment">//sda线输出</span></span><br><span class="line">	IIC_SCL=<span class="number">0</span>;</span><br><span class="line">	IIC_SDA=<span class="number">0</span>;    <span class="comment">//STOP:when CLK is high DATA change form low to high</span></span><br><span class="line"> 	delay_us(<span class="number">4</span>);</span><br><span class="line">	IIC_SCL=<span class="number">1</span>; </span><br><span class="line">	IIC_SDA=<span class="number">1</span>;    <span class="comment">//发送I2C总线结束信号</span></span><br><span class="line">	delay_us(<span class="number">4</span>);							   	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送数据后，等待应答信号到来</span></span><br><span class="line"><span class="comment">//返回值：1，接收应答失败，IIC直接退出</span></span><br><span class="line"><span class="comment">//        0，接收应答成功，什么都不做</span></span><br><span class="line">u8 IIC_Wait_Ack(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	u8 ucErrTime=<span class="number">0</span>;</span><br><span class="line">	SDA_IN();      <span class="comment">//SDA设置为输入  </span></span><br><span class="line">	IIC_SDA=<span class="number">1</span>;delay_us(<span class="number">1</span>);	   </span><br><span class="line">	IIC_SCL=<span class="number">1</span>;delay_us(<span class="number">1</span>);	 </span><br><span class="line">	<span class="keyword">while</span>(READ_SDA)</span><br><span class="line">	&#123;</span><br><span class="line">		ucErrTime++;</span><br><span class="line">		<span class="keyword">if</span>(ucErrTime&gt;<span class="number">250</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			IIC_Stop();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	IIC_SCL=<span class="number">0</span>;    <span class="comment">//时钟输出0 	   </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//产生ACK应答</span></span><br><span class="line"><span class="built_in">void</span> IIC_Ack(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	IIC_SCL=<span class="number">0</span>;</span><br><span class="line">	SDA_OUT();</span><br><span class="line">	IIC_SDA=<span class="number">0</span>;</span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SCL=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不产生ACK应答		    </span></span><br><span class="line"><span class="built_in">void</span> IIC_NAck(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	IIC_SCL=<span class="number">0</span>;</span><br><span class="line">	SDA_OUT();</span><br><span class="line">	IIC_SDA=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SCL=<span class="number">1</span>;</span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;					 				     </span><br><span class="line"><span class="comment">//IIC发送一个字节</span></span><br><span class="line"><span class="comment">//返回从机有无应答</span></span><br><span class="line"><span class="comment">//1，有应答</span></span><br><span class="line"><span class="comment">//0，无应答			  </span></span><br><span class="line"><span class="built_in">void</span> IIC_Send_Byte(u8 txd)   <span class="comment">//结合起始、应答、结束信号才能传输数据</span></span><br><span class="line">&#123;                        </span><br><span class="line">    u8 t;   </span><br><span class="line">	SDA_OUT(); 	    </span><br><span class="line">    IIC_SCL=<span class="number">0</span>;            <span class="comment">//拉低时钟开始数据传输</span></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">    &#123;              </span><br><span class="line">        <span class="comment">//IIC_SDA=(txd&amp;0x80)&gt;&gt;7;</span></span><br><span class="line">		<span class="keyword">if</span>((txd&amp;<span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>)</span><br><span class="line">			IIC_SDA=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			IIC_SDA=<span class="number">0</span>;</span><br><span class="line">		txd&lt;&lt;=<span class="number">1</span>; 	  </span><br><span class="line">		delay_us(<span class="number">2</span>);       <span class="comment">//对TEA5767这三个延时都是必须的</span></span><br><span class="line">		IIC_SCL=<span class="number">1</span>;</span><br><span class="line">		delay_us(<span class="number">2</span>); </span><br><span class="line">		IIC_SCL=<span class="number">0</span>;	</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">    &#125;	 </span><br><span class="line">&#125; 	    </span><br><span class="line"><span class="comment">//读1个字节，ack=1时，发送ACK，ack=0，发送nACK   </span></span><br><span class="line">u8 IIC_Read_Byte(unsigned char ack)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char i,receive=<span class="number">0</span>;</span><br><span class="line">	SDA_IN();        <span class="comment">//SDA设置为输入</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++ )</span><br><span class="line">	&#123;</span><br><span class="line">        IIC_SCL=<span class="number">0</span>; </span><br><span class="line">        delay_us(<span class="number">2</span>);</span><br><span class="line">		IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        receive&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(READ_SDA)receive++;   </span><br><span class="line">		delay_us(<span class="number">1</span>); </span><br><span class="line">    &#125;					 </span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">        IIC_NAck();        <span class="comment">//发送nACK</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        IIC_Ack();         <span class="comment">//发送ACK   </span></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>IIC</tag>
      </tags>
  </entry>
  <entry>
    <title>lua基本语法</title>
    <url>/2020/06/11/lua%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>两个减号是单行注释<br><code>--</code></p>
<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> --]]</span></span><br></pre></td></tr></table></figure>

<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p> 以下列出了 Lua的保留关键字。保留关键字不能作为常量或变量或其他用户自定义标示符：</p>
<table>
<thead>
<tr>
<th>and</th>
<th>break</th>
<th>do</th>
<th>else</th>
</tr>
</thead>
<tbody><tr>
<td>elseif</td>
<td>end</td>
<td>false</td>
<td>for</td>
</tr>
<tr>
<td>function</td>
<td>if</td>
<td>in</td>
<td>local</td>
</tr>
<tr>
<td>nil</td>
<td>not</td>
<td>or</td>
<td>repeat</td>
</tr>
<tr>
<td>return</td>
<td>then</td>
<td>true</td>
<td>until</td>
</tr>
<tr>
<td>while</td>
<td>goto</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="lua变量"><a href="#lua变量" class="headerlink" title="lua变量"></a>lua变量</h1><p>Lua 变量有三种类型：全局变量、局部变量、表中的域。</p>
<p><strong>Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- test.lua 文件脚本</span></span><br><span class="line">a = <span class="number">5</span>               <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">5</span>         <span class="comment">-- 局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joke</span><span class="params">()</span></span></span><br><span class="line">    c = <span class="number">5</span>           <span class="comment">-- 全局变量</span></span><br><span class="line">    <span class="keyword">local</span> d = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line"><span class="built_in">print</span>(c,d)          <span class="comment">--&gt; 5 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line">    b = <span class="number">6</span>           <span class="comment">-- 对局部变量重新赋值</span></span><br><span class="line">    <span class="built_in">print</span>(a,b);     <span class="comment">--&gt; 6 6</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,b)      <span class="comment">--&gt; 5 6</span></span><br></pre></td></tr></table></figure>



<h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><p>Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。<br><code>a,b=10,20   --a=10,b=20</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a,b,c)</span></span>             --&gt; <span class="number">0</span>   <span class="number">1</span>   nil</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> = a+<span class="number">1</span>, b+<span class="number">1</span>, b+<span class="number">2</span>     -- value of b+<span class="number">2</span> is ignored</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a,b)</span></span>               --&gt; <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a,b,c)</span></span>             --&gt; <span class="number">0</span>   nil   nil</span><br></pre></td></tr></table></figure>

<p><code>a, b = f()</code><br>f()返回两个值，第一个赋给a，第二个赋给b。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>对 table 的索引使用方括号 []。Lua 也提供了 . 操作</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">t[i]</span><br><span class="line">t<span class="selector-class">.i</span>                 -- 当索引为字符串类型时的一种简化写法</span><br><span class="line"><span class="function"><span class="title">gettable_event</span><span class="params">(t,i)</span></span> -- 采用索引访问本质上是一个类似这样的函数调用</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> site = &#123;&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> site[<span class="string">"key"</span>] = <span class="string">"www.runoob.com"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">print</span>(site[<span class="string">"key"</span>])</span></span><br><span class="line">www.runoob.com</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">print</span>(site.key)</span></span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>函数指针</title>
    <url>/2020/06/30/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="什么是函数指针？"><a href="#什么是函数指针？" class="headerlink" title="什么是函数指针？"></a>什么是函数指针？</h2><p>这个问题从定义的角度来看很好理解，指向函数的指针就是函数指针，但是我们如何声明一个函数指针呢？又如何将一个地址强制转换为某一个类型的函数指针呢？这里看下面一个例子源码：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">function</span><span class="params">(int a)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">       a = 5;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="params">(*pfunc)</span><span class="params">(int)</span>;</span></span><br></pre></td></tr></table></figure>
<p>很简单，上面这段代码声明了一个函数fucntion和一个函数指针pfunc, 它指向的函数就是一个具有void返回值，int参数的函数。<br>如果将function函数的地址给pfunc指针，可以简单的通过下面两种赋值：<br><code>pfunc = function//函数名就是地址;或者pfunc = &amp;function</code><br>通过指针调用该函数，也有两种方法：<br><code>pfunc(5); 或 (*pfunc)(5);</code></p>
<hr>
<h2 id="返回函数指针的函数声名"><a href="#返回函数指针的函数声名" class="headerlink" title="返回函数指针的函数声名"></a>返回函数指针的函数声名</h2><p>先看一下下面的需求1) 定义一个函数；2) 该函数具有以下特点，两个参数，返回值是函数指针，并且一个参数也是函数指针。假如返回值和参数函数指针同为void (<em>)(int); 另一个函数参数是int型。该函数定义名称为my_func。<br>假如说my_func的返回值是int，是不是它的定义可以这么写：`int my_func(int, void (</em>)(int))<code></code>void (<em>pfunc)(int)；`<br>其中pfunc 等价于 void (\</em>)(int)。pfunc就是my_func(int, void (*)(int))。现在如果将两者代替一下是不是就成了这种格式：<br><code>void (*my_func(int, void(*)(int)))(int)</code></p>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>例如语句 typedef int *apple; 理解它的正确步骤是这样的：先别看typedef，就剩下int *apple; 这个语句再简单不过，就是声明了一个指向整型变量的指针apple (注意：定义只是一种特殊的声明)，加上typedef之后就解释成声明了一种指向整型变量指针的类型apple 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>
<p>盖住 typedef不看 ，再简单不过，sighandler_t就是一个函数指针，指向的函数接受一个整型参数并返回一个无类型指针 。加上typedef之后sighandler_t就是一种新的类型，就可以像int一样地去用它，不同的是它声明是一种函数指针，这种指针指向的函数接受一个整型参数并返回一个无类型指针 </p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile基本语法</title>
    <url>/2020/06/10/makefile/</url>
    <content><![CDATA[<h1 id="什么是Makefile"><a href="#什么是Makefile" class="headerlink" title="什么是Makefile"></a>什么是Makefile</h1><p>使用 GCC 编译器在 Linux 进行 C 语言编译，通过在终端执行 gcc 命令来完成 C 文件的编译，如果我们的工程只有一两个 C 文件还好，需要输入的命令不多，当文件有几十、上百甚至上万个的时候用终端输入 GCC 命令的方法显然是不现实的。如果我们能够编写一个文件，这个文件描述了编译哪些源码文件、如何编译那就好了，每次需要编译工程的时只需要使用这个文件就行了。这种问题怎么可能难倒聪明的程序员，为此提出了一个解决大工程编译的工具： make，描述哪些文件需要编译、哪些需要重新编译的文件就叫做 Makefile，命令即可完成整个工程的自动编译，极大的提高了软件开发的效率。</p>
<h1 id="Makefile语法"><a href="#Makefile语法" class="headerlink" title="Makefile语法"></a>Makefile语法</h1><h2 id="Makefile文件的创建和运行"><a href="#Makefile文件的创建和运行" class="headerlink" title="Makefile文件的创建和运行"></a>Makefile文件的创建和运行</h2><p>在工程目录下创建名为“Makefile”的文件，文件名一定要叫做“Makefile”！！！区分大小写</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">main: main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br><span class="line">  gcc -o main main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br><span class="line">main<span class="selector-class">.o</span>: main.c</span><br><span class="line">  gcc -c main.c</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-class">.o</span>: <span class="selector-tag">input</span>.c</span><br><span class="line">  gcc -c <span class="selector-tag">input</span>.c</span><br><span class="line">calcu<span class="selector-class">.o</span>: calcu.c</span><br><span class="line">  gcc -c calcu.c</span><br><span class="line"> </span><br><span class="line">clean:</span><br><span class="line">  rm *.o</span><br><span class="line">  rm main</span><br></pre></td></tr></table></figure>
<p>上述代码中所有行首需要空出来的地方一定要<strong><em>使用“TAB”键！</em></strong>不要使用空格键！ 这是Makefile 的语法要求</p>
<a id="more"></a>

<p>Makefile 编写好以后我们就可以使用 make 命令来编译我们的工程了，直接在命令行中输入“make”即可， make 命令会在当前目录下查找是否存在“Makefile”这个文件，如果存在的话就会按照 Makefile 里面定义的编译方式进行编译。使用命令“make”编译完成以后就会在当前工程目录下生成各种.o 和可执行文件，说明我们编译成功了。</p>
<h2 id="规则格式"><a href="#规则格式" class="headerlink" title="规则格式"></a>规则格式</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">目标…... : 依赖文件集合……</span><br><span class="line">命令 <span class="number">1</span></span><br><span class="line">命令 <span class="number">2</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>比如下面这条规则：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">main : main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br><span class="line">	gcc -o main main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br></pre></td></tr></table></figure>
<p>这条规则的目标是 main， main.o、 input.o 和 calcu.o 是生成 main 的依赖文件，如果要更新目标 main，就必须先更新它的所有依赖文件，如果依赖文件中的任何一个有更新，那么目标也必须更新，“更新”就是执行一遍规则中的命令列表。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">main: main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br><span class="line">  gcc -o main main<span class="selector-class">.o</span> <span class="selector-tag">input</span><span class="selector-class">.o</span> calcu.o</span><br><span class="line">main<span class="selector-class">.o</span>: main.c</span><br><span class="line">  gcc -c main.c</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-class">.o</span>: <span class="selector-tag">input</span>.c</span><br><span class="line">  gcc -c <span class="selector-tag">input</span>.c</span><br><span class="line">calcu<span class="selector-class">.o</span>: calcu.c</span><br><span class="line">  gcc -c calcu.c</span><br><span class="line"> </span><br><span class="line">clean:</span><br><span class="line">  rm *.o</span><br><span class="line">  rm main</span><br></pre></td></tr></table></figure>
<p>上述代码中一共有 5 条规则，1-2 行为第一条规则， 3-4 行为第二条规则， 5-6 行为第三条规则， 7-8 行为第四条规则， 10-12 为第五条规则， make 命令在执行这个 Makefile 的时候其执<br>行步骤如下：<br>首先更新第一条规则中的 main，第一条规则的目标成为默认目标，只要默认目标更新了那么就认为 Makefile 的工作，完成了整个 Makefile 就是为了完成这个工作。在第一次编译的时候由于 main 还不存在，因此第一条规则会执行，第一条规则依赖于文件 main.o、 input.o 和 calcu.o这个三个.o 文件，这三个.o 文件目前还都没有，因此必须先更新这三个文件。 make 会查找以这三个.o 文件为目标的规则并执行。以 main.o 为例，发现更新 main.o 的是第二条规则，因此会执行第二条规则，第二条规则里面的命令为“gcc –c main.c”，这行命令很熟悉了吧，就是不链接编译 main.c，生成 main.o，其它两个.o 文件同理。最后一个规则目标是 clean，它没有依赖文件，因此会默认为依赖文件都是最新的，所以其对应的命令不会执行，当我们想要执行 clean 的话可以直接使用命令“make clean”，执行以后就会删除当前目录下所有的.o 文件以及 main，因此clean 的功能就是完成工程的清理</p>
<h2 id="Makefile变量"><a href="#Makefile变量" class="headerlink" title="Makefile变量"></a>Makefile变量</h2><p><strong><em>不像 C 语言中的变量有 int、 char等各种类型， Makefile 中的变量都是字符串！</em></strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Makefile 变量的使用</span></span><br><span class="line">objects = main.o input.o calcu.o</span><br><span class="line"><span class="section">main: <span class="variable">$(objects)</span></span></span><br><span class="line">  gcc -o main <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>第 1 行是注释， Makefile 中可以写注释，注释开头要用符号“#”，不能用 C 语言中的“//”或者“/**/”！第 2 行我们定义了一个变量 objects，并且给这个变量进行了赋值，其值为字符串“main.o input.o calcu.o”，第 3 和 4 行使用到了变量 objects，Makefile 中变量的引用方法是“$(变量名)”，比如本例中的“$(objects)”就是使用变量 objects。</p>
<h3 id="赋值符"><a href="#赋值符" class="headerlink" title="赋值符"></a>赋值符</h3><p>1.赋值符“=”</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">name = zou</span><br><span class="line">curname = <span class="variable">$(name)</span></span><br><span class="line">name = zouding</span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">  @echo curname: <span class="variable">$(curname)</span></span><br></pre></td></tr></table></figure>
<p>在 Makefile 要输出一串字符的话使用“echo”，就和 C 语言中的“printf”一样，“echo”前面加了个“@”符号，因为 Make 在执行的过程中会自动输出命令执行过程，在命令前面加上“@”的话就不会输出命令执行过程<br>print为zouding，“=”变量的真实值取决于它所引用的变量的最后一次有效值</p>
<p>2.赋值符“：=“</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">name = zou</span><br><span class="line">curname := <span class="variable">$(name)</span></span><br><span class="line">name = zouding</span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">  @echo curname: <span class="variable">$(curname)</span></span><br></pre></td></tr></table></figure>
<p>print的为zou，”:=”只能使用前面赋的值</p>
<p>3.赋值符”？=“<br><code>curname?=zouding</code><br>上述代码的意思就是，如果变量 curname 前面没有被赋值，那么此变量就是“zouding”，如果前面已经赋过值了，那么就使用前面赋的值。</p>
<p>4.追加变量”+=“</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o inpiut.o</span><br><span class="line">objects += calcu.o</span><br></pre></td></tr></table></figure>
<p>一开始变量 objects 的值为“main.o input.o”，后面我们给他追加了一个“calcu.o”，因此变量 objects 变成了<br>“main.o input.o calcu.o”，这个就是变量的追加。</p>
<h2 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h2><p>所谓自动化变量就是这种变量会把模式中所定义的一系列的文件自动的挨个取出，直至所有的符合模式的文件都取完，自动化变量只应该出现在规则的命令中，常用的自动化变量如表 </p>
<table>
<thead>
<tr>
<th>自动化变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>$@</td>
<td align="left">规则中的目标集合，在模式规则中，如果有多个目标的话，“$@”表示匹配模式中定义的目标集合。</td>
</tr>
<tr>
<td>$%</td>
<td align="left">当目标是函数库的时候表示规则中的目标成员名，如果目标不是函数库文件，那么其值为空。</td>
</tr>
<tr>
<td>$&lt;</td>
<td align="left">依赖文件集合中的第一个文件，如果依赖文件是以模式(即“%” )定义的，那么“$&lt;”就是符合模式的一系列的文件集合。</td>
</tr>
<tr>
<td>$?</td>
<td align="left">所有比目标新的依赖目标集合，以空格分开。</td>
</tr>
<tr>
<td>$^</td>
<td align="left">所有依赖文件的集合，使用空格分开，如果在依赖文件中有多个重复的文件，“$^”会去除重复的依赖文件，值保留一份。</td>
</tr>
<tr>
<td>$+</td>
<td align="left">和“$^”类似，但是当依赖文件存在重复的话不会去除重复的依赖文件。</td>
</tr>
<tr>
<td>$*</td>
<td align="left">这个变量表示目标模式中”%”及其之前的部分，如果目标是 test/a.test.c，目标模式为 a.%.c，那么“$*”就是 test/a.test。</td>
</tr>
</tbody></table>
<p>常用的三种：<strong><em>$@、 $&lt;和$^</em></strong></p>
<h2 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h2><p>模式规则中，至少在规则的目标定定义中要包涵“%”，否则就是一般规则，目标中的“%”表示对文件名的匹配，“%”表示长度任意的非空字符串，比如“%.c”就是所有的以.c 结尾的文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">objects</span> = <span class="string">main.o input.o calcu.o</span></span><br><span class="line"><span class="attr">main</span>: <span class="string">$(objects)</span></span><br><span class="line">	<span class="attr">gcc</span> <span class="string">-o main $(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%.o</span> : <span class="string">%.c</span></span><br><span class="line">	<span class="attr">gcc</span> <span class="string">-c $&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">clean</span>:<span class="string"></span></span><br><span class="line">	<span class="attr">rm</span> <span class="string">*.o</span></span><br><span class="line">	<span class="attr">rm</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<p>上诉代码可代替2.1中的代码，更加精简</p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>Makefile 中的函数是已经定义好的，我们直接使用，不支持我们自定义函数。<br>函数的用法如下：<br><code>$(函数名 参数集合）</code></p>
<p>1、函数 subst<br>函数 subst 用来完成字符串替换，调用形式如下：<br><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code><br>此函数的功能是将字符串<text>中的<from>内容替换为<to>，函数返回被替换以后的字符串，比如如下示例：<br><code>$(subst zou,ZZK,my name is zzk)</code><br>把字符串“my name is zzk”中的“zzk”替换为“zou”，替换完成以后的字符串为“my name is zou”。</p>
<p>2、函数 patsubst<br>函数 patsubst 用来完成模式字符串替换，使用方法如下：<br><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code><br>此函数查找字符串<text>中的单词是否符合模式<pattern>，如果匹配就用<replacement>来替换掉， <pattern>可以使用包括通配符“%”，表示任意长度的字符串，函数返回值就是替换后<br>的字符串。如果<replacement>中也包涵“%”，那么<replacement>中的“%”将是<pattern>中的那个“%”所代表的字符串，比如：<br><code>$(patsubst %.c,%.o,a.c b.c c.c)</code><br>将字符串“a.c b.c c.c”中的所有符合“%.c”的字符串，替换为“%.o”，替换完成以后的字符串为“a.o b.o c.o”。</p>
<p>符串为“a.o b.o c.o”。<br>3、函数 dir<br>函数 dir 用来获取目录，使用方法如下：<br><code>$(dir &lt;names…&gt;)</code><br>此函数用来从文件名序列<names>中提取出目录部分，返回值是文件名序列<names>的目录部分，比如：<br><code>$(dir &lt;/src/a.c&gt;)</code><br>提取文件“/src/a.c”的目录部分，也就是“/src”。</p>
<p>4、函数 notdir<br>函数 notdir 看名字就是知道去除文件中的目录部分，也就是提取文件名，用法如下：<br><code>$(notdir &lt;names…&gt;)</code><br>此函数用与从文件名序列<names>中提取出文件名非目录部分，比如：<br><code>$(notdir &lt;/src/a.c&gt;)</code><br>提取文件“/src/a.c”中的非目录部分，也就是文件名“a.c”。</p>
<p>5、函数 foreach<br>foreach 函数用来完成循环，用法如下：<br><code>$(foreach &lt;var&gt;, &lt;list&gt;,&lt;text&gt;)</code><br>此函数的意思就是把参数list中的单词逐一取出来放到参数var中，然后再执行text所包含的表达式。每次text都会返回一个字符串，循环的过程中， text中所包含的每个字符串会以空格隔开，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串将会是函数 foreach 函数的返回值。</p>
]]></content>
      <categories>
        <category>Makefile基本语法</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>文件描述符与虚拟内存</title>
    <url>/2020/06/28/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>虚拟内存：为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。<br>如果真的给这个进程分配全部的物理内存，那绝大部分物理内存就浪费了。所以现在一般采用分页的技术(将虚拟地址空间和物理内存划分成固定大小的小块)，建立页表，把进程的虚拟地址空间页映射到物理内存的页帧上。这里页表保存的就是映射关系。然后随着进程的运行，就会按需分配页，那些长时间未使用的页帧又会被操作系统回收。</p>
<p>创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟 进程地址空间。 之所以是 4GB ，是因为在 32 位的操作系统中，一个指针长度是 4 字节  （32位）， 2的32次 方个地址寻址能力是从 0x00000000~0xFFFFFFFF 即为 4GB 大小的容量。32位Linux下，一个进程空间4G，内核占1G，用户留3G，一个线程默认8M，所以最多380个左右线程。<br><img src="/images/36.png" alt=""></p>
<ul>
<li>内核空间： 内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</li>
<li>用户3GB：<br>1）栈空间：特点是由系统管理，先进后出，里面放了局部变量、函数形参、自动变量。<br>2）堆空间：特点是由用户管理，先进后出，我们可以用malloc、ralloc、calloc来分配空间。<br>3）数据段：数据段里面又分三块，第一块是bss，保存未初始化的全局变量；第二块是rodata，保存了常量；第三块  是.data（静态数据区）保存了初始化的全局变量还有static修饰的变量。<br>4）代码段：存放了源代码。</li>
</ul>
<h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h2><p>Linux内核把进程称为任务（task），进程的虚拟地址空间分为用户虚拟地址空间和内核虚拟地址空间，所有进程共享内核虚拟地址空间，每个进程有独立的用户虚拟地址空间。<br>我们知道，每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h文件中可以查看struct task_struct 结构体定义。其内部成员有很多，重点掌握以下部分即可：</p>
<ul>
<li>进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</li>
<li>进程的状态，有就绪、运行、挂起、停止等状态。</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器。</li>
<li>描述虚拟地址空间的信息。</li>
<li>描述控制终端的信息。</li>
<li>当前工作目录（Current Working Directory）。</li>
<li>umask掩码。</li>
<li>文件描述符表，包含很多指向file结构体的指针。</li>
<li>和信号相关的信息。</li>
<li>用户id和组id。</li>
<li>会话（Session）和进程组。</li>
<li>进程可以使用的资源上限（Resource Limit）。</li>
</ul>
<h2 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h2><p>Mmu的作用是把虚拟地址映射到物理地址，当程序开始运行会产生进程同时产生虚拟内存(虚拟内存可以比物理内存大)，编程的时候我们使用的为虚拟地址（比如0xd8884）MMU把这个虚拟地址对应到实际地址上，加载cpu时从实际地址上取。每同一个进程都是独立的，同一个程序的不同两个进程都需要进行地址映射<br><img src="/images/32.png" alt=""></p>
<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>件描述符表、文件表、索引结点表存放地点：</p>
<ul>
<li>每个进程都有一个属于自己的文件描述符表。</li>
<li>文件表存放在内核空间，由系统里的所有进程共享。</li>
<li>索引结点表也存放在内核空间，由所有进程所共享。</li>
</ul>
<p><img src="/images/37.png" alt=""><br>规律：</p>
<ol>
<li>文件描述符就是一个整形数字</li>
<li>每个进程默认打开 0、1、2 三个文件描述符， 新的文件描述符都是从 3 开始分配（标准输入(0)、标准输出(1)、标准错误(2)）</li>
<li>一个文件描述符被回收后可以再次被分配 (文件描述符并不是递增的)</li>
<li>每个进程单独维护了一个文件描述符的集合</li>
</ol>
<p>例子：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd_a = <span class="built_in">open</span>(<span class="string">"demo.txt"</span>, O_RDONLY);</span><br><span class="line">	<span class="keyword">int</span> fd_b = <span class="built_in">open</span>(<span class="string">"demo.txt"</span>, O_RDONLY);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fd_a = %d, fd_b = %d \n"</span>, fd_a, fd_b);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">$ gcc test.c -o test</span><br><span class="line">$ ./test</span><br><span class="line">$ fd_a = <span class="number">3</span>, fd_b = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一次打开</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="built_in">open</span>(<span class="string">"demo.txt"</span>, O_RDONLY);</span><br><span class="line">  <span class="comment">// 第二次打开</span></span><br><span class="line">	<span class="keyword">int</span> b = <span class="built_in">open</span>(<span class="string">"demo.txt"</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a = %d, b = %d \n"</span>, a, b);</span><br><span class="line">  <span class="comment">// 关闭a文件描述符</span></span><br><span class="line">	<span class="built_in">close</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第三次打开</span></span><br><span class="line">	<span class="keyword">int</span> c = <span class="built_in">open</span>(<span class="string">"demo.txt"</span>, O_RDONLY);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"b = %d, c = %d \n"</span>, b, c);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">$ gcc test.c -o test</span><br><span class="line">$ ./test</span><br><span class="line">$ a = <span class="number">3</span>, b = <span class="number">4</span></span><br><span class="line">  b = <span class="number">4</span>, c = <span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件描述符</tag>
      </tags>
  </entry>
  <entry>
    <title>lua数据类型</title>
    <url>/2020/06/11/lua%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nil</td>
<td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td>
</tr>
<tr>
<td>boolean</td>
<td>包含两个值：false和true。</td>
</tr>
<tr>
<td>number</td>
<td>表示双精度类型的实浮点数</td>
</tr>
<tr>
<td>string</td>
<td>字符串由一对双引号或单引号来表示</td>
</tr>
<tr>
<td>function</td>
<td>由 C 或 Lua 编写的函数</td>
</tr>
<tr>
<td>userdata</td>
<td>表示任意存储在变量中的C数据结构</td>
</tr>
<tr>
<td>thread</td>
<td>表示执行的独立线路，用于执行协同程序</td>
</tr>
<tr>
<td>table</td>
<td>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td>
</tr>
</tbody></table>
<a id="more"></a>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(<span class="string">"Hello world"</span>))</span>      --&gt;</span> string</span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(<span class="number">10.4</span>*<span class="number">3</span>))</span>             --&gt;</span> number</span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(<span class="built_in">print</span>))</span>              --&gt;</span> <span class="keyword">function</span></span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(type))</span>               --&gt;</span> <span class="keyword">function</span></span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(<span class="literal">true</span>))</span>               --&gt;</span> boolean</span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(nil))</span>                --&gt;</span> nil</span><br><span class="line"><span class="built_in">print</span><span class="function"><span class="params">(type(type(X)))</span>            --&gt;</span> string</span><br></pre></td></tr></table></figure>


<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>nil 类型表示一种没有任何有效值，它只有一个值 – nil，例如打印一个没有赋值的变量，便会输出一个 nil 值：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">&gt; print(<span class="name">type</span>(<span class="name">a</span>))</span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉</p>
<p>nil 作比较时应该加上双引号 “：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">type</span>(<span class="type">X</span>)</span><br><span class="line"><span class="title">nil</span></span><br><span class="line">&gt; <span class="keyword">type</span>(<span class="type">X</span>)==nil</span><br><span class="line"><span class="title">false</span></span><br><span class="line">&gt; <span class="keyword">type</span>(<span class="type">X</span>)=="nil"</span><br><span class="line"><span class="title">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><p>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是 false，其他的都为 true，<strong><em>数字 0 也是 true</em></strong></p>
<hr>
<h2 id="number（数字）"><a href="#number（数字）" class="headerlink" title="number（数字）"></a>number（数字）</h2><p>Lua 默认只有一种 number 类型 – double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型</p>
<hr>
<h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p>字符串由一对双引号或单引号来表示。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">string1</span> = <span class="string">"this is string1"</span></span><br><span class="line"><span class="attr">string2</span> = <span class="string">'this is string2'</span></span><br></pre></td></tr></table></figure>
<p>也可以用 2 个方括号 “[[]]” 来表示”一块”字符串。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">html = [[</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.runoob.com/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">]]</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure>

<p>在对一个数字字符串上进行算术操作时，Lua会尝试将这个数字字符串转成一个数字</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="title">print</span>(<span class="string">"2"</span> + <span class="number">6</span>)</span></span><br><span class="line"><span class="number">8.0</span></span><br><span class="line">&gt; <span class="function"><span class="title">print</span>(<span class="string">"2"</span> + <span class="string">"6"</span>)</span></span><br><span class="line"><span class="number">8.0</span></span><br><span class="line">&gt; <span class="function"><span class="title">print</span>(<span class="string">"2 + 6"</span>)</span></span><br><span class="line"><span class="number">2</span> + <span class="number">6</span></span><br><span class="line">&gt; <span class="function"><span class="title">print</span>(<span class="string">"-2e2"</span> * <span class="string">"6"</span>)</span></span><br><span class="line">-<span class="number">1200.0</span></span><br></pre></td></tr></table></figure>
<p>字符串连接使用的是 ..  如</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; <span class="builtin-name">print</span>(<span class="string">"a"</span> <span class="built_in">..</span> <span class="string">'b'</span>)</span><br><span class="line">ab</span><br><span class="line">&gt; <span class="builtin-name">print</span>(157 <span class="built_in">..</span> 428)</span><br><span class="line">157428</span><br></pre></td></tr></table></figure>

<p>使用 # 来计算字符串的长度，放在字符串前面</p>
<figure class="highlight plain"><figcaption><span>len </span></figcaption><table><tr><td class="code"><pre><span class="line">&gt; print(#len)</span><br><span class="line">14</span><br><span class="line">&gt; print(#&quot;www.runoob.com&quot;)</span><br><span class="line">14</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="table表"><a href="#table表" class="headerlink" title="table表"></a>table表</h2><p>在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:<br><code>local tbl1 = {}  --创建一个空表</code><br><code>local tbl2 = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}  --初始化表</code></p>
<p>不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="string">"key"</span>] = <span class="string">"value"</span></span><br><span class="line"><span class="type">key</span> = <span class="number">10</span></span><br><span class="line">a[<span class="type">key</span>] = <span class="number">22</span></span><br><span class="line">a[<span class="type">key</span>] = a[<span class="type">key</span>] + <span class="number">11</span></span><br><span class="line">for k, v in pairs(a) do</span><br><span class="line">    print(k .. <span class="string">" : "</span> .. v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key :</span> <span class="string">value</span></span><br><span class="line"><span class="attr">10 :</span> <span class="number">33</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与父子进程</title>
    <url>/2020/06/24/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-并发"><a href="#1-并发" class="headerlink" title="1.并发"></a>1.并发</h1><p><img src="/images/31.png" alt=""><br>并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。<br>例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</p>
<h2 id="单道程序设计"><a href="#单道程序设计" class="headerlink" title="单道程序设计"></a>单道程序设计</h2><p>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p>
<h2 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h2><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。<br>时钟中断即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。<br>在多道程序设计模型中，多个进程轮流使用CPU (分时复用CPU资源)。而当下常见CPU为纳秒级，1秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。<br>1s = 1000ms, 1ms = 1000us, 1us = 1000ns    1000000000<br>实质上，并发是宏观并行，微观串行！            —–推动了计算机蓬勃发展，将人类引入了多媒体时代。</p>
<h1 id="2-CPU和MMU"><a href="#2-CPU和MMU" class="headerlink" title="2.CPU和MMU"></a>2.CPU和MMU</h1><p><img src="/images/34.png" alt=""><br>程序存储在硬盘，运行是先加载到内存，然后进入缓冲区，然后一条一条指令进入CPU 运算(寄存器在cpu里面)<br>预取器从缓冲区(cache)选取指令交给译码器判断运行指令所需要的寄存器，然后加载到相应的寄存器组</p>
<h2 id="虚拟地址、物理地址与MMU"><a href="#虚拟地址、物理地址与MMU" class="headerlink" title="虚拟地址、物理地址与MMU"></a>虚拟地址、物理地址与MMU</h2><ul>
<li>虚拟内存：为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。<br>如果真的给这个进程分配全部的物理内存，那绝大部分物理内存就浪费了。所以现在一般采用分页的技术(将虚拟地址空间和物理内存划分成固定大小的小块)，建立页表，把进程的虚拟地址空间页映射到物理内存的页帧上。这里页表保存的就是映射关系。然后随着进程的运行，就会按需分配页，那些长时间未使用的页帧又会被操作系统回收。</li>
</ul>
<p>创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟 进程地址空间。 之所以是 4GB ，是因为在 32 位的操作系统中，一个指针长度是 4 字节  （32位）， 2的32次 方个地址寻址能力是从 0x00000000~0xFFFFFFFF 即为 4GB 大小的容量。32位Linux下，一个进程空间4G，内核占1G，用户留3G，一个线程默认8M，所以最多380个左右线程。<br>用户3GB：<br>1）栈空间：特点是由系统管理，先进后出，里面放了局部变量、函数形参、自动变量。<br>2）堆空间：特点是由用户管理，先进后出，我们可以用malloc、ralloc、calloc来分配空间。<br>3）数据段：数据段里面又分三块，第一块是bss，保存未初始化的全局变量；第二块是rodata，保存了常量；第三块  是.data（静态数据区）保存了初始化的全局变量还有static修饰的变量。<br>4）代码段：存放了源代码。</p>
<ul>
<li>Mmu的作用是把虚拟地址映射到物理地址，当程序开始运行会产生进程同时产生虚拟内存(虚拟内存可以比物理内存大)，编程的时候我们使用的为虚拟地址（比如0xd8884）MMU把这个虚拟地址对应到实际地址上，加载cpu时从实际地址上取。每同一个进程都是独立的，同一个程序的不同两个进程都需要进行地址映射<br><img src="/images/32.png" alt=""></li>
</ul>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程，shell也是一个进程，所以不同目录打开的终端输入相同ls命令有不同结果，c程序也是一个进程）</p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>进程基本的状态有5种。分别为初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。<br><img src="/images/35.png" alt=""></p>
<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p>打开一个可执行文件也是创建一个进程，例如。./a.out(父进程是bash)、ls也是一个可执行程序（看环境变量path节）</p>
<h3 id="fork函数-用于创建子进程"><a href="#fork函数-用于创建子进程" class="headerlink" title="fork函数(用于创建子进程)"></a>fork函数(用于创建子进程)</h3><p>创建一个子进程。<br>pid_t fork(void);    失败返回-1；成功返回两个值：① 父进程返回子进程的ID(非负)    ②子进程返回 0<br>pid_t类型（实际上就是int型）表示进程ID，但为了表示-1，它是有符号整型。(0不是有效进程ID，init最小，为1)<br>       注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子需【各自】返回一个。<br><img src="/images/33.png" alt=""><br><strong><em>在语句fork()之前，只有一个进程在执行这段代码</em></strong>，但在这条语句之后，就变成两个进程在执行了，这两个进程的几乎完全相同，将要执行的下一条语句都是if(fpid&lt;0)<br>为什么两个进程的fpid不同呢，这与fork函数的特性有关。fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：<br>    1）在父进程中，fork返回新创建子进程的进程ID；<br>    2）在子进程中，fork返回0；<br>    3）如果出现错误，fork返回一个负值；<br>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">pid_t</span> fpid; <span class="comment">//fpid表示fork函数返回的值  </span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;  </span><br><span class="line">    fpid=fork();   </span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error in fork!"</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am the child process, my process id is %d/n"</span>,getpid());   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是爹的儿子/n"</span>); </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am the parent process, my process id is %d/n"</span>,getpid());   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是孩子他爹/n"</span>);  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"统计结果是: %d/n"</span>,count);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">结果：</span><br><span class="line"> i am the child <span class="built_in">process</span>, my <span class="built_in">process</span> id is <span class="number">5574</span></span><br><span class="line">    我是爹的儿子</span><br><span class="line">    统计结果是: <span class="number">1</span></span><br><span class="line">    i am the parent <span class="built_in">process</span>, my <span class="built_in">process</span> id is <span class="number">5573</span></span><br><span class="line">    我是孩子他爹</span><br><span class="line">    统计结果是: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>特殊例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main ()</span><br><span class="line">&#123;</span><br><span class="line">         <span class="keyword">pid_t</span> pid;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"fork!"</span>);    <span class="comment">//printf("fork!\n")</span></span><br><span class="line"></span><br><span class="line">         pid=fork();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">"error in fork!\n"</span>);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">"i am the child process, my process id is %d\n"</span>,getpid());</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">"i am the parent process, my process id is %d\n"</span>,getpid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序打印输出了两个”fork！”这不免让人以为是child process从#include处开始执行，所以也执行了printf(“fork!”); 语句。<br>其实不然，出现这种问题的原因在于：<br>这就跟Printf的缓冲机制有关了,printf某些内容时,操作系统仅仅是把该内容放到了stdout的缓冲队列里了,并没有实际的写到屏幕上 。但是,只要看到有\n, 则会立即刷新stdout,因此就马上能够打印了.</p>
<p>main函数(parent process)运行了printf(“fork!”) 后, “fork!”仅仅被放到了缓冲里,再运行到fork时,缓冲里面的 AAAAAA 被子进程(child process)继承了,因此在子进程度stdout缓冲里面就也有了”fork!”。所以,你最终看到的会是 “fork!” 被printf了2次!!!!<br>而main函数(parent process)运行 printf(“fork!\n”)后,”fork!” 被立即打印到了屏幕上,之后fork到的子进程(child process)里的stdout缓冲里不会有”fork!”内容 因此你看到的结果会是”fork!” 被printf了1次!!!!</p>
<h3 id="循环创建n个子进程-重点"><a href="#循环创建n个子进程-重点" class="headerlink" title="循环创建n个子进程(重点)"></a>循环创建n个子进程(重点)</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> #include &lt;stdio.h&gt;</span><br><span class="line"> <span class="number">2</span> #include &lt;stdlib.h&gt;</span><br><span class="line"> <span class="number">3</span> #include &lt;unistd.h&gt;</span><br><span class="line"> <span class="number">4</span> <span class="built_in">int</span> main(<span class="built_in">void</span>)&#123;</span><br><span class="line"> <span class="number">5</span>     <span class="built_in">int</span> i;</span><br><span class="line"> <span class="number">6</span>     pid_t pid;</span><br><span class="line"> <span class="number">7</span>     printf(<span class="string">"xxxxxx\n"</span>);</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"> <span class="number">9</span>         pid = fork();</span><br><span class="line"><span class="number">10</span>         <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="number">11</span>             <span class="keyword">break</span>;  <span class="comment">//如果没有break，子进程也会创建子进程，创建的进程个数为2^n-1，</span></span><br><span class="line">                          <span class="comment">//如果是子进程抢到cpu第一次break后执行下面子进程代码，如果是父进程抢到cpu则继续for</span></span><br><span class="line"><span class="number">12</span>         &#125;</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line">		sleep(i);  <span class="comment">//保证shell的子进程最后结束</span></span><br><span class="line"><span class="number">14</span>     <span class="keyword">if</span>(i &lt; <span class="number">5</span>)&#123;</span><br><span class="line"><span class="number">15</span>         </span><br><span class="line"><span class="number">16</span>         printf(<span class="string">"I am %d child, pid = %u\n"</span>,i+<span class="number">1</span>,getpid);</span><br><span class="line"><span class="number">17</span>     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="number">18</span>        </span><br><span class="line"><span class="number">19</span>         printf(<span class="string">"I am parent\n"</span>);</span><br><span class="line"><span class="number">20</span>     &#125;</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">23</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul>
<li>getpid函数<br>  获取当前进程ID<br>  pid_t getpid(void);        </li>
<li>getppid函数<br>  获取当前进程的父进程ID<br>  pid_t getppid(void);</li>
<li>getuid函数<br>  获取当前进程实际用户ID：uid_t getuid(void);<br>  获取当前进程有效用户ID：uid_t geteuid(void);</li>
<li>getgid函数<br>  获取当前进程使用用户组ID：gid_t getgid(void);<br>  获取当前进程有效用户组ID：gid_t getegid(void);</li>
</ul>
<h2 id="子父进程的区别"><a href="#子父进程的区别" class="headerlink" title="子父进程的区别"></a>子父进程的区别</h2><p>关于资源：子进程得到的是除了代码段是与父进程共享的以外，其他所有的都是得到父进程的一个副本，子进程的所有资源都继承父进程，得到父进程资源的副本，既然为副本，也就是说，二者并不共享地址空间。，两个是单独的进程，继承了以后二者就没有什么关联了，子进程单独运行。（采用写时复制技术）<br>关于文件描述符：继承父进程的文件描述符时，相当于调用了dup函数，父子进程共享文件表项，即共同操作同一个文件，一个进程修改了文件，另一个进程也知道此文件被修改了。</p>
<hr>
<p>刚fork()后：<br>父子相同处(0-3G部分一样): 全局变量(运行后父子全局变量互不影响)、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号屏蔽字，信号处理方式（注意：子进程拷贝了父进程数据空间、堆、栈等资源的副本，父子进程间不共享这些存储空间，共享的空间只有代码段，子进程修改一个全局变量，父进程的这个全局变量不会改变，因为是一个副本。）<br>父子不同处: 1.进程ID   2.fork返回值   3.父进程ID    4.进程运行时间    5.闹钟(定时器)   6.未决信号集</p>
<hr>
<p><strong>注意：父子进程共享：1. 文件描述符(fork之前打开文件)  2. mmap建立的映射区(与全局变量有差别，子父进程的数据共享，进程间通信详解)</strong><br>似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？<br>当然不是!父子进程间遵循<strong><em>读时共享写时复制的原则</em></strong>。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。<br>读时共享写时复制这一机制是由MMU来实现的。<br>注意：只有进程空间的各段的内容要发生变化时（子进程或父进程进行写操作时，都会引起复制），才会将父进程的内容复制一份给子进程。在fork之后两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。即父子进程在逻辑上仍然是严格相互独立的两个进程，各自维护各自的参数，只是在物理上实现了读时共享，写时复制。 </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程与进程</title>
    <url>/2020/06/21/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="虚拟地址、物理地址与MMU"><a href="#虚拟地址、物理地址与MMU" class="headerlink" title="虚拟地址、物理地址与MMU"></a>虚拟地址、物理地址与MMU</h1><ul>
<li>虚拟内存：为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。<br>如果真的给这个进程分配全部的物理内存，那绝大部分物理内存就浪费了。所以现在一般采用分页的技术(将虚拟地址空间和物理内存划分成固定大小的小块)，建立页表，把进程的虚拟地址空间页映射到物理内存的页帧上。这里页表保存的就是映射关系。然后随着进程的运行，就会按需分配页，那些长时间未使用的页帧又会被操作系统回收。</li>
</ul>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟 进程地址空间。 之所以是 4GB ，是因为在 32 位的操作系统中，一个指针长度是 4 字节  （32位）， 2的32次 方个地址寻址能力是从 0x00000000~0xFFFFFFFF 即为 4GB 大小的容量。32位Linux下，一个进程空间4G，内核占1G，用户留3G，一个线程默认8M，所以最多380个左右线程。<br>用户3GB：<br>1）栈空间：特点是由系统管理，先进后出，里面放了局部变量、函数形参、自动变量。<br>2）堆空间：特点是由用户管理，先进后出，我们可以用malloc、ralloc、calloc来分配空间。<br>3）数据段：数据段里面又分三块，第一块是bss，保存未初始化的全局变量；第二块是rodata，保存了常量；第三块  是.data（静态数据区）保存了初始化的全局变量还有static修饰的变量。<br>4）代码段：存放了源代码。</p>
<ul>
<li>Mmu的作用是把虚拟地址映射到物理地址，当程序开始运行会产生进程同时产生虚拟内存(虚拟内存可以比物理内存大)，编程的时候我们使用的为虚拟地址（比如0xd8884）MMU把这个虚拟地址对应到实际地址上，加载cpu时从实际地址上取。每同一个进程都是独立的，同一个程序的不同两个进程都需要进行地址映射<br><img src="/images/32.png" alt=""></li>
</ul>
<h1 id="并发，同步，异步，互斥，阻塞，非阻塞的理解"><a href="#并发，同步，异步，互斥，阻塞，非阻塞的理解" class="headerlink" title="并发，同步，异步，互斥，阻塞，非阻塞的理解"></a>并发，同步，异步，互斥，阻塞，非阻塞的理解</h1><p><img src="/images/31.png" alt=""></p>
<ul>
<li>并发(concurrency)：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥。<ul>
<li>互斥，是指分布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。 </li>
<li>同步，是指分布在不同进程之间的若干程序片断，它们的运行必须严格按照规定的 某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。 显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。也就是说互斥是两个线程之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要安照某种次序来运行相应的线程（也是一种互斥）！　</li>
</ul>
</li>
</ul>
<p>总结：<br>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。　　<br>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
<ul>
<li>异步(asynchronous)：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。<strong><em>线程就是实现异步的一个方式。</em></strong>异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。<br>同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情， 而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知）。<br>异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。</li>
<li>阻塞，非阻塞<br>阻塞调用是指调用结果返回之前，调用者会进入阻塞状态等待。只有在得到结果之后才会返回。<br>非阻塞调用是指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</li>
</ul>
<hr>
<p>阻塞调用：比如 socket 的 recv()，调用这个函数的线程如果没有数据返回，它会一直阻塞着，也就是 recv() 后面的代码都不会执行了，程序就停在 recv() 这里等待，所以一般把 recv() 放在单独的线程里调用。</p>
<p>非阻塞调用：比如非阻塞socket 的 send()，调用这个函数，它只是把待发送的数据复制到TCP输出缓冲区中，就立刻返回了，线程并不会阻塞，数据有没有发出去 send() 是不知道的，不会等待它发出去才返回的。</p>
<p>*一般来说IO模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。</p>
<h1 id="进程线程的基本概念"><a href="#进程线程的基本概念" class="headerlink" title="进程线程的基本概念"></a>进程线程的基本概念</h1><h1 id="1-1-1什么是进程，线程？也就是问彼此有什么区别？"><a href="#1-1-1什么是进程，线程？也就是问彼此有什么区别？" class="headerlink" title="1.1.1什么是进程，线程？也就是问彼此有什么区别？"></a>1.1.1什么是进程，线程？也就是问彼此有什么区别？</h1><p>答：进程是程序执行时的一个实例，即它是程序已经执行到课中程度的数据结构的汇集。从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。<br>线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。一个进程由几个线程组成（拥有很多相对独立的执行流的用户程序共享应用程序的大部分数据结构），线程与同属一个进程的其他的线程共享进程所拥有的全部资源。进程是资源（CPU、内存等）分配的基本单位，线程是CPU调度和分配的基本单位（程序执行的最小单位）。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">进程：独立地址空间，拥有PCB</span><br><span class="line">线程：也有PCB，但没有独立的地址空间<span class="comment">(共享)</span></span><br><span class="line">区别：在于是否共享地址空间。</span><br></pre></td></tr></table></figure>

<ol>
<li>当我们运行一个程序的时候，系统就会创建一个进程，并分配地址空间和其他资源，最后把进程加入就绪队列直到分配到CPU时间就可以正式运行了。</li>
<li>线程是进程的一个执行流，有一个初学者可能误解的概念，进程就像一个容器一样，包括程序运行的程序段、数据段等信息，但是进程其实是不能用来运行代码的，真正运行代码的是进程里的线程。</li>
<li>进程拥有自己的资源空间，每启动一个进程，系统就会为它分配地址空间；而线程与CPU资源分配无关，多个线程共享同一进程内的资源，使用相同的地址空间。<br>一个进程可以包含若干个线程。</li>
</ol>
<hr>
<p>采用形象一点的比喻更好，比如（取自知乎）：<br>开个QQ，开了一个进程；开了迅雷，开了一个进程。<br>在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。<br>所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。所以一个进程管着多个线程。</p>
<h1 id="1-1-2-多进程、多线程的优缺点"><a href="#1-1-2-多进程、多线程的优缺点" class="headerlink" title="1.1.2 多进程、多线程的优缺点"></a>1.1.2 多进程、多线程的优缺点</h1><p>答：</p>
<h2 id="多进程优点"><a href="#多进程优点" class="headerlink" title="多进程优点"></a>多进程优点</h2><ul>
<li>每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系；</li>
<li>通过增加CPU，就可以容易扩充性能；</li>
<li>可以尽量减少线程加锁/解锁的影响，极大提高性能，就算是线程运行的模块算法效率低也没关系；</li>
<li>每个子进程都有独立地址空间和相关资源，总体能够达到的性能上限非常大</li>
</ul>
<h2 id="多进程缺点"><a href="#多进程缺点" class="headerlink" title="多进程缺点"></a>多进程缺点</h2><ul>
<li>逻辑控制复杂，需要和主程序交互；</li>
<li>需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算</li>
<li>多进程调度开销比较大；</li>
</ul>
<h2 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h2><ul>
<li>无需跨进程边界；</li>
<li>程序逻辑和控制方式简单；</li>
<li>所有线程可以直接共享内存和变量等；</li>
<li>线程方式消耗的总资源比进程方式好；</li>
</ul>
<h2 id="多线程缺点"><a href="#多线程缺点" class="headerlink" title="多线程缺点"></a>多线程缺点</h2><ul>
<li>每个线程与主程序共用地址空间，受限于2GB地址空间；</li>
<li>线程之间的同步和加锁控制比较麻烦；</li>
<li>一个线程的崩溃可能影响到整个程序的稳定性；</li>
<li>到达一定的线程数程度后，即使再增加CPU也无法提高性能，例如Windows Server 2003，大约是1500个左右的线程数就快到极限了（线程堆栈设定为1M），如果设定线程堆栈为2M，还达不到1500个线程总数；</li>
<li>线程能够提高的总性能有限，而且线程多了之后，线程本身的调度也是一个麻烦事儿，需要消耗较多的CPU</li>
</ul>
<hr>
<h1 id="1-1-3-什么时候用进程，什么时候用线程"><a href="#1-1-3-什么时候用进程，什么时候用线程" class="headerlink" title="1.1.3 什么时候用进程，什么时候用线程"></a>1.1.3 什么时候用进程，什么时候用线程</h1><p>解析：还是同一个思想，进程是“要用来做大事”的，而线程是“各自做件小事，合作完成大事”，结合上节新鲜出炉的优缺点我们就很好理解什么时候用进程或者线程了。</p>
<p>答：</p>
<p>1）创建和销毁较频繁使用线程，因为创建进程花销大嘛。</p>
<p>2）需要大量数据传送使用线程，因为多线程切换速度快，不需要跨越进程边界。</p>
<p>3）并行操作使用线程。线程是为了实现并行操作的一个手段，也就是刚才说的需要多个并行操作“合作完成大事”，当然是使用线程啦。</p>
<p>4）最后可以总结为：安全稳定选进程；快速频繁选线程；</p>
<h1 id="1-1-4-多进程、多线程同步（通讯）的方法"><a href="#1-1-4-多进程、多线程同步（通讯）的方法" class="headerlink" title="1.1.4 多进程、多线程同步（通讯）的方法"></a>1.1.4 多进程、多线程同步（通讯）的方法</h1><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程间通信的几种主要手段：    </p>
<ol>
<li>管道（Pipe）及有名管道（FIFO）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；    </li>
<li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期 信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上， 该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，sigaction函数重新实现了signal函数）；    </li>
<li>报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针其他通信机制运行效率较低设计的。往往与其它通信机制，如信号量结合使用， 来达到进程间的同步及互斥。   </li>
<li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。             </li>
<li>套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix 系统上：Linux和System V的变种都支持套接字。</li>
</ol>
<hr>
<p>一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：<br>    ① 管道 (使用最简单)<br>    ② 信号 (开销最小)<br>    ③ 共享映射区 (无血缘关系)<br>    ④ 本地套接字 (最稳定)</p>
<h2 id="线程同步，最常用的是互斥锁、条件变量、信号量、读写锁"><a href="#线程同步，最常用的是互斥锁、条件变量、信号量、读写锁" class="headerlink" title="线程同步，最常用的是互斥锁、条件变量、信号量、读写锁"></a>线程同步，最常用的是互斥锁、条件变量、信号量、读写锁</h2><ul>
<li><p>互斥锁:通过锁机制实现线程间的同步。同一时刻只允许一个线程执行一个关键部分的代码</p>
</li>
<li><p>条件变量（cond）:利用线程间共享的全局变量进行同步的一种机制。条件变量上的基本操作有：触发条件(当条件变为 true 时)；等待条件，挂起线程直到其他线程触发条件。</p>
</li>
<li><p>信号量:如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。</p>
</li>
</ul>
<h2 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h2><p>互斥量和文件锁</p>
<h1 id="1-1-5什么是线程的同步与互斥？"><a href="#1-1-5什么是线程的同步与互斥？" class="headerlink" title="1.1.5什么是线程的同步与互斥？"></a>1.1.5什么是线程的同步与互斥？</h1><ul>
<li>互斥：指在某一时刻指允许一个进程运行其中的程序片，具有排他性和唯一性。<br>对于线程A和线程B来讲，在同一时刻，只允许一个线程对临界资源进行操作，即当A进入临界区对资源操作时，B就必须等待；当A执行完，退出临界区后，B才能对临界资源进行操作</li>
<li>同步：指的是在互斥的基础上，实现进程之间的有序访问。假设现有线程A和线程B，线程A需要往缓冲区写数据，线程B需要从缓冲区读数据，但他们之间存在一种制约关系，即当线程A写的时候，B不能来拿数据；B在拿数据的时候A不能往缓冲区写，也就是说，只有当A写完数据（或B取走数据），B才能来读数据（或A才能往里写数据）。这种关系就是一种线程的同步关系。</li>
</ul>
<p>*注释：<br>    临界资源：能够被多个线程共享的数据/资源。<br>    临界区：对临界资源进行操作的那一段代码</p>
<h1 id="1-1-6孤儿进程、僵尸进程、守护进程的概念"><a href="#1-1-6孤儿进程、僵尸进程、守护进程的概念" class="headerlink" title="1.1.6孤儿进程、僵尸进程、守护进程的概念"></a>1.1.6孤儿进程、僵尸进程、守护进程的概念</h1><p>进程在终止前向父进程发送SIGCLD信号，父进程调用wait等待子进程的退出！</p>
<ul>
<li><p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程没有什么危害，因为将来结束时，init进程会完成他们状态收集的工作。而僵尸进程在内核中还有一些信息(包括进程号)，需要及时处理；但是每个进程都要或长或短地经历僵尸进程的状态。</p>
</li>
<li><p>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程(ps进程状态为“Z”)。</p>
</li>
<li><p>守护进程：是在后台运行不受终端控制的进程（如输入、输出等）。网络服务大部分就是守护进程。<br>孤儿进程没有什么危害，因为将来结束时，init进程会完成他们状态收集的工作。而僵尸进程在内核中还有一些信息(包括进程号)，需要及时处理；但是每个进程都要或长或短地经历僵尸进程的状态。</p>
</li>
</ul>
<h2 id="如何创建守护进程："><a href="#如何创建守护进程：" class="headerlink" title="如何创建守护进程："></a>如何创建守护进程：</h2><ol>
<li><p>创建子进程，父进程退出：因为守护进程是在后台运行不受终端控制的进程，父进程退出后控制台就以为该程序结束了，我们就可以在子进程进行自己的任务，同时用户仍可以在控制台输入指令，从而在形式上做到了与控制台脱离。</p>
</li>
<li><p>在子进程中创建新的会话(脱离控制终端)：使用系统函数setsid()来创建一个新的会话，并担任该会话组的组长，摆脱原会话的控制==&gt;摆脱原进程的控制==&gt;摆脱原控制台的控制。</p>
</li>
<li><p>改变当前目录为根目录：1.1.7小节知道子进程继承父进程的目录信息，但进程运行时对当前目录下的文件系统不能卸载，这会有很多隐藏的麻烦，建议使用根目录作为当前目录，当然也可以使用其他目录。</p>
</li>
<li><p>重设文件权限掩码，关闭文件描述符：子进程还继承父进程文件权限掩码，即屏蔽掉文件权限中的对应位。此时子进程需将其重置为0，即在此时有大的权限，从而提高该守护进程灵活度。最后，关系从父进程继承的已经打开的文件描述符，如不进行关闭将造成浪费资源以及子进程所有文件系统无法卸载等错误。</p>
</li>
</ol>
<h1 id="1-1-7正确处理僵尸进程的方法"><a href="#1-1-7正确处理僵尸进程的方法" class="headerlink" title="1.1.7正确处理僵尸进程的方法"></a>1.1.7正确处理僵尸进程的方法</h1><ul>
<li><p>如何杀死僵尸进程(不能之间kill掉)<br>方法有二：</p>
<ol>
<li>重启服务器电脑，这个是最简单，最易用的方法，但是如果你服务器电脑上运行有其他的程序，那么这个方法，代价很大。所以，尽量使用下面一种方法。</li>
<li>找到该defunct僵尸进程的父进程，将该进程的父进程杀掉，则此defunct进程将自动消失。</li>
</ol>
</li>
<li><p>如何预防僵尸进程</p>
<ul>
<li>在父进程创建子进程之前，就向系统申明自己并不会对这个子进程的exit动作进行任何关注行为，这样的话，子进程一旦退出后，系统就不会去等待父进程的操作，而是直接将该子进程的资源回收掉，也就不会出现僵尸进程了。具体的办法就是，在父进程的初始化函数中，调用这个函数：signal(SIGCHLD,SIG_IGN)；</li>
<li>如果上述语句没来得及调用，也有另外一个办法。那就是在创建完子进程后，用waitpid等待子进程返回，也能达到上述效果；</li>
<li>如果上述两个办法都不愿意采用，那还有一招：在父进程创建子进程的时候，连续调用两次fork()，而且使紧跟的子进程直接退出，使其孙子进程成为孤儿进程，从而init进程将代替父进程来接手，负责清除这个孤儿进程。于是，父进程就无需进行任何的清理行为，系统会自动处理；</li>
</ul>
</li>
</ul>
<h1 id="1-1-9父子进程之间的关系"><a href="#1-1-9父子进程之间的关系" class="headerlink" title="1.1.9父子进程之间的关系"></a>1.1.9父子进程之间的关系</h1><p>对于cpu来说子父进程都一样<br>关于资源：子进程得到的是除了代码段是与父进程共享的以外，其他所有的都是得到父进程的一个副本，子进程的所有资源都继承父进程，得到父进程资源的副本，既然为副本，也就是说，二者并不共享地址空间。，两个是单独的进程，继承了以后二者就没有什么关联了，子进程单独运行。（采用写时复制技术）<br>关于文件描述符：继承父进程的文件描述符时，相当于调用了dup函数，父子进程共享文件表项，即共同操作同一个文件，一个进程修改了文件，另一个进程也知道此文件被修改了。</p>
<ul>
<li>刚fork之后：<br>父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式…<br>父子不同处: 1.进程ID   2.fork返回值   3.父进程ID    4.进程运行时间    5.闹钟(定时器)   6.未决信号集</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>模块与包</title>
    <url>/2020/06/15/%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/</url>
    <content><![CDATA[<p>Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。以下为创建自定义模块 module.lua，文件代码格式如下：</p>
<a id="more"></a>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 文件名为 module.lua</span></span><br><span class="line"><span class="comment">-- 定义一个名为 module 的模块</span></span><br><span class="line">module = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个常量</span></span><br><span class="line">module.constant = <span class="string">"这是一个常量"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">"这是一个公有函数！\n"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"这是一个私有函数！"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func3</span><span class="params">()</span></span></span><br><span class="line">    func2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> module</span><br></pre></td></tr></table></figure>
<p>由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。<br>上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用.</p>
<h2 id="require-函数"><a href="#require-函数" class="headerlink" title="require 函数"></a>require 函数</h2><p>Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如：<br><code>require(&quot;模块名&quot;)</code>或者 <code>require &quot;模块名&quot;</code></p>
<figure class="highlight plain"><figcaption><span>别名变量 m</span></figcaption><table><tr><td class="code"><pre><span class="line">local m &#x3D; require(&quot;module&quot;)</span><br><span class="line"> </span><br><span class="line">print(m.constant)</span><br><span class="line"> </span><br><span class="line">m.func3()</span><br><span class="line"></span><br><span class="line">执行：</span><br><span class="line">这是一个常量</span><br><span class="line">这是一个私有函数！</span><br></pre></td></tr></table></figure>


<h1 id="C-包"><a href="#C-包" class="headerlink" title="C 包"></a>C 包</h1><p>Lua和C是很容易结合的，使用 C 为 Lua 写包。</p>
<p>与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。</p>
<p>方法1：将包含C函数的代码生成库文件，如Linux的so，或Windows的DLL，同时拷贝到Lua代码所在的当前目录，或者是LUA_CPATH环境变量所指向的目录，以便于Lua解析器可以正确定位到他们。在我当前的Windows系统中，我将其copy到”C:\ProgramFiles\Lua\5.1\clibs&quot;，这里包含了所有Lua可调用的C库。</p>
<p>方法2：Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。所以典型的调用的例子如下:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">"/usr/local/lua/lib/libluasocket.so"</span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">loadlib</span>(<span class="built_in">path</span>, <span class="string">"luaopen_socket"</span>)</span><br></pre></td></tr></table></figure>
<p>.so为共享动态库<br>loadlib 函数加载指定的库并且连接到 Lua，然而它并不打开库（也就是说没有调用初始化函数），反之他返回初始化函数作为 Lua 的一个函数，这样我们就可以直接在Lua中调用他。<br>也可以把该Dll放到你的Lua能搜寻到的目录——当前目录、Lua安装目录下的clibs目录，然后通过require函数导入。</p>
<p>如果加载动态库或者查找初始化函数时出错，loadlib 将返回 nil 和错误信息。我们可以修改前面一段代码，使其检测错误然后调用初始化函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">"/usr/local/lua/lib/libluasocket.so"</span></span><br><span class="line"><span class="comment">-- 或者 path = "C:\\windows\\luasocket.dll"，这是 Window 平台下</span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadlib</span>(<span class="built_in">path</span>, <span class="string">"luaopen_socket"</span>))</span><br><span class="line">f()  <span class="comment">-- 真正打开库</span></span><br></pre></td></tr></table></figure>
<p>一般情况下我们期望二进制的发布库包含一个与前面代码段相似的 stub 文件，安装二进制库的时候可以随便放在某个目录，只需要修改 stub 文件对应二进制库的实际路径即可。</p>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua 协同程序(coroutine)</title>
    <url>/2020/06/16/%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="线程和协同程序区别"><a href="#线程和协同程序区别" class="headerlink" title="线程和协同程序区别"></a>线程和协同程序区别</h2><p>线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。<br>在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。<br>协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>coroutine.create()</td>
<td>创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用</td>
</tr>
<tr>
<td>coroutine.resume()</td>
<td>重启 coroutine，和 create 配合使用</td>
</tr>
<tr>
<td>coroutine.yield()    挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果</td>
<td></td>
</tr>
<tr>
<td>coroutine.status()</td>
<td>查看 coroutine 的状态</td>
</tr>
<tr>
<td>注：coroutine 的状态有三种：dead，suspended，running，具体什么时候有这样的状态请参考下面的程序</td>
<td></td>
</tr>
<tr>
<td>coroutine.wrap（）</td>
<td>创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复</td>
</tr>
<tr>
<td>coroutine.running()</td>
<td>返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 corouting 的线程号</td>
</tr>
</tbody></table>
<a id="more"></a>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- coroutine_test.lua 文件</span></span><br><span class="line">co = coroutine.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">coroutine.<span class="built_in">resume</span>(co, <span class="number">1</span>)   <span class="comment">-- 1</span></span><br><span class="line"><span class="built_in">print</span>(coroutine.<span class="built_in">status</span>(co))  <span class="comment">-- dead</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"----------"</span>)</span><br><span class="line"> </span><br><span class="line">co = coroutine.<span class="built_in">wrap</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span></span><br><span class="line">        <span class="built_in">print</span>(i);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">co(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"----------"</span>)</span><br><span class="line"> </span><br><span class="line">co2 = coroutine.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">print</span>(coroutine.<span class="built_in">status</span>(co2))  <span class="comment">--running</span></span><br><span class="line">                <span class="built_in">print</span>(coroutine.<span class="built_in">running</span>()) <span class="comment">--thread:XXXXXX</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            coroutine.<span class="built_in">yield</span>()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">coroutine.<span class="built_in">resume</span>(co2) <span class="comment">--1</span></span><br><span class="line">coroutine.<span class="built_in">resume</span>(co2) <span class="comment">--2</span></span><br><span class="line">coroutine.<span class="built_in">resume</span>(co2) <span class="comment">--3</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(coroutine.<span class="built_in">status</span>(co2))   <span class="comment">-- suspended</span></span><br><span class="line"><span class="built_in">print</span>(coroutine.<span class="built_in">running</span>())</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"----------"</span>)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">dead</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">running</span></span><br><span class="line">thread: <span class="number">0x7fb801c05868</span>    <span class="literal">false</span></span><br><span class="line">suspended</span><br><span class="line">thread: <span class="number">0x7fb801c04c88</span>    <span class="literal">true</span></span><br><span class="line"><span class="comment">----------</span></span><br></pre></td></tr></table></figure>
<p>当使用resume触发事件的时候，create的coroutine函数就被执行了，当遇到yield的时候就代表挂起当前线程，等候再次resume触发事件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> co = coroutine.<span class="built_in">create</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line">        coroutine.<span class="built_in">yield</span>(a+b,a-b)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(coroutine.<span class="built_in">resume</span>(co,<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="literal">true</span> <span class="number">30</span> <span class="number">10</span>    <span class="comment">--在resume()调用返回的内容时，第一个值为true则表示没有错误，而后面所有的值都是对应yield()传入的参数：</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"foo 函数输出"</span>, a)</span><br><span class="line">    <span class="keyword">return</span> coroutine.<span class="built_in">yield</span>(<span class="number">2</span> * a) <span class="comment">-- 返回  2*a 的值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">co = coroutine.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">(a , b)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第一次协同程序执行输出"</span>, a, b) <span class="comment">-- co-body 1 10</span></span><br><span class="line">    <span class="keyword">local</span> r = foo(a + <span class="number">1</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第二次协同程序执行输出"</span>, r)</span><br><span class="line">    <span class="keyword">local</span> r, s = coroutine.<span class="built_in">yield</span>(a + b, a - b)  <span class="comment">-- a，b的值为第一次调用协同程序时传入</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第三次协同程序执行输出"</span>, r, s)</span><br><span class="line">    <span class="keyword">return</span> b, <span class="string">"结束协同程序"</span>                   <span class="comment">-- b的值为第二次调用协同程序时传入</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line">       </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"main"</span>, coroutine.<span class="built_in">resume</span>(co, <span class="number">1</span>, <span class="number">10</span>)) <span class="comment">-- true, 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"--分割线----"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"main"</span>, coroutine.<span class="built_in">resume</span>(co, <span class="string">"r"</span>)) <span class="comment">-- true 11 -9</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"---分割线---"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"main"</span>, coroutine.<span class="built_in">resume</span>(co, <span class="string">"x"</span>, <span class="string">"y"</span>)) <span class="comment">-- true 10 end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"---分割线---"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"main"</span>, coroutine.<span class="built_in">resume</span>(co, <span class="string">"x"</span>, <span class="string">"y"</span>)) <span class="comment">-- cannot resume dead coroutine</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"---分割线---"</span>)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">第一次协同程序执行输出    <span class="number">1</span>    <span class="number">10</span></span><br><span class="line">foo 函数输出    <span class="number">2</span></span><br><span class="line">main    <span class="literal">true</span>    <span class="number">4</span></span><br><span class="line"><span class="comment">--分割线----</span></span><br><span class="line">第二次协同程序执行输出    r</span><br><span class="line">main    <span class="literal">true</span>    <span class="number">11</span>    <span class="number">-9</span></span><br><span class="line"><span class="comment">---分割线---</span></span><br><span class="line">第三次协同程序执行输出    x    y</span><br><span class="line">main    <span class="literal">true</span>    <span class="number">10</span>    结束协同程序</span><br><span class="line"><span class="comment">---分割线---</span></span><br><span class="line">main    <span class="literal">false</span>    cannot <span class="built_in">resume</span> dead coroutine</span><br><span class="line"><span class="comment">---分割线---</span></span><br></pre></td></tr></table></figure>


<ul>
<li>在resume()调用返回的内容时，第一个值为true则表示没有错误，而后面所有的值都是对应yield()传入的参数：</li>
<li>在第一次调用resume()时，并没有对应的yield()在等待它，因此所有传递给resume()的额外参数都将视为协同程序主函数的参数：</li>
<li>yield()返回的值就是对应resume()额外传入的参数：</li>
<li>当一个协同程序结束时，它的主函数所返回的值都将作为对应resume()的返回值:</li>
<li>当协调程序里面有yield()时，调用resume()会在yield()处挂起，并且yield()传入的参数会作为此次resume()的返回值；当协同程序中调用return执行完毕后，此次恢复该协同程序的resume()会把return的返回值作为自己的返回值</li>
</ul>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua迭代器</title>
    <url>/2020/06/12/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="ipairs-和pairs-的区别"><a href="#ipairs-和pairs-的区别" class="headerlink" title="ipairs()和pairs()的区别"></a>ipairs()和pairs()的区别</h1><p>pairs会遍历表中所有的key-value值，而ipairs会根据key的数值从1开始加1递增遍历对应的table[i]值，直到出现第一个不是按1递增的数值时候退出。</p>
<p>下面我们以例子说明一下吧</p>
<p>stars = {[1] = “Sun”, [2] = “Moon”, [5] = ‘Earth’}</p>
<p>for i, v in pairs(stars) do</p>
<p>   print(i, v)</p>
<p>end</p>
<a id="more"></a>

<p>使用pairs()将会遍历表中所有的数据，输出结果是：</p>
<p>1    Sun<br>2    Moon<br>5    Earth</p>
<p>如果使用ipairs()的话，</p>
<p>for i, v in ipairs(stars) do</p>
<p>   print(i, v)</p>
<p>end</p>
<p>当i的值遍历到第三个元素时，i的值为5，此时i并不是上一个次i值（2）的+1递增，所以遍历结束，结果则会是：</p>
<p>1    Sun<br>2    Moon</p>
<p>ipairs()和pairs()的区别就是这么简单。</p>
<h1 id="泛型-for-迭代器"><a href="#泛型-for-迭代器" class="headerlink" title="泛型 for 迭代器"></a>泛型 for 迭代器</h1><p>泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。<br>泛型 for 迭代器提供了集合的 key/value 对，语法格式如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<!--more-->


<p>上面代码中，k, v为变量列表；pairs(t)为表达式列表。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">array</span> = &#123;"Google", "Runoob"&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for key</span>,<span class="keyword">value</span> <span class="keyword">in</span> ipairs(<span class="keyword">array</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   print(key, <span class="keyword">value</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">执行结果：</span><br><span class="line"><span class="number">1</span>  Google</span><br><span class="line"><span class="number">2</span>  Runoob</span><br></pre></td></tr></table></figure>

<p>Lua 默认提供的迭代函数 ipairs。</p>
<p>泛型 for 的执行过程：</p>
<ul>
<li>首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。</li>
<li>第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。</li>
<li>第三，将迭代函数返回的值赋给变量列表。</li>
<li>第四，如果返回的第一个值为nil循环结束，否则执行循环体。</li>
<li>第五，回到第二步再次调用迭代函数</li>
</ul>
<h1 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h1><p>无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。</p>
<p>每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素。</p>
<p>以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">--求数字<span class="built_in">j</span>到N的平方</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(N, j)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">j</span> &lt;= N</span><br><span class="line">    then</span><br><span class="line">        <span class="keyword">return</span>  <span class="built_in">j</span>+<span class="number">1</span> ,  <span class="built_in">j</span>*<span class="built_in">j</span> --  这里的<span class="built_in">j</span>+<span class="number">1</span> 是为了传给<span class="keyword">for</span>的<span class="built_in">i</span>值，类似++<span class="built_in">i</span>，否则<span class="built_in">i</span>一直不变，死循环</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">--         迭代器函数、恒定状态、控制变量的初值</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>,n in square ,     <span class="number">3</span> ,    <span class="number">1</span></span><br><span class="line">do</span><br><span class="line">    --这里的<span class="built_in">i</span>,n是square返回的</span><br><span class="line">    print(<span class="built_in">i</span><span class="number">-1</span> ,<span class="string">"的平方是"</span> , n)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iter</span> <span class="params">(a, i)</span></span></span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span></span><br><span class="line">    local v = a[<span class="built_in">i</span>]</span><br><span class="line">    <span class="keyword">if</span> v then</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">i</span>, v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> iter, a, <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当 Lua 调用 ipairs(a) 开始循环时，他获取三个值：迭代函数 iter、状态常量 a、控制变量初始值 0；然后 Lua 调用 iter(a,0) 返回 1, a[1]（除非 a[1]=nil）；第二次迭代调用 iter(a,1) 返回 2, a[2]……直到第一个 nil 元素。</p>
<h1 id="多状态的迭代器"><a href="#多状态的迭代器" class="headerlink" title="多状态的迭代器"></a>多状态的迭代器</h1><p>很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到 table 内，将 table 作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在 table 内，所以迭代函数通常不需要第二个参数。</p>
<p>以下实例我们创建了自己的迭代器：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">array</span> = &#123;"Google", "Runoob"&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> elementIterator (collection)</span><br><span class="line">   <span class="keyword">local</span> <span class="keyword">index</span> = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> count = #collection</span><br><span class="line">   <span class="comment">-- 闭包函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">function</span> ()</span><br><span class="line">      <span class="keyword">index</span> = <span class="keyword">index</span> + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">index</span> &lt;= count</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">         <span class="comment">--  返回迭代器的当前元素</span></span><br><span class="line">         <span class="keyword">return</span> collection[<span class="keyword">index</span>]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elementIterator(<span class="keyword">array</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   print(element)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Google</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure>
<p>以上实例中我们可以看到，elementIterator 内使用了闭包函数，实现计算集合大小并输出各个元素。</p>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM篇</title>
    <url>/2020/06/21/%E9%9D%A2%E8%AF%95ARM/</url>
    <content><![CDATA[<h2 id="FIQ比IRQ快的原因："><a href="#FIQ比IRQ快的原因：" class="headerlink" title="FIQ比IRQ快的原因："></a>FIQ比IRQ快的原因：</h2><p>A、FIQ模式的R8–R14寄存器是独有的，FIQ处理程序可以不必执行保存和恢复中断现场的指令。<br>B、FIQ可以将ISR直接放在FIQ后面的地址空间，不需要跳转。</p>
<h2 id="在ARM系统中，在函数调用的时候，参数是通过哪种方式传递的"><a href="#在ARM系统中，在函数调用的时候，参数是通过哪种方式传递的" class="headerlink" title="在ARM系统中，在函数调用的时候，参数是通过哪种方式传递的"></a>在ARM系统中，在函数调用的时候，参数是通过哪种方式传递的</h2><p>当参数小于等于4的时候是通过r0-r3寄存器来进行传递的，当参数大于4的时候是通过压栈的方式进行传递。</p>
<h2 id="简述SPI-UART-I2C三种传输方式"><a href="#简述SPI-UART-I2C三种传输方式" class="headerlink" title="简述SPI,UART,I2C三种传输方式"></a>简述SPI,UART,I2C三种传输方式</h2><ul>
<li><p>SPI：高速同步串行口，首发独立，可同步进行<br>  SPI接口主要应用在EEPROM，Flash，实时时钟，A/D转化器，数字信号处理，是一种全双工同步通讯总线，该接口一般使用四条线：串行时钟线（sck），主出从入线，主入从出线，低电平有效地的从机选择线。</p>
</li>
<li><p>I2C协议：是单片机与其他芯片进行通讯的协议：<br>  A、只要求两条总线线路，一条是串行时钟线，一条是串行数据线；<br>  B、通过软件设定地址<br>  C、是一个多主机总线，如果两个或更多主机同时初始化数据传送可通过冲突检测和仲裁防止数据破坏；<br>  D、I2C总线传输的是数据的总高位</p>
<ul>
<li>UART：主要是由一个modem（调制解调器），可以将模拟信号量转化成数字信号量。</li>
</ul>
</li>
</ul>
<a id="more"></a>



<h2 id="在ARM的汇编程序中，有如下几种伪指令：、-、-、-、-。"><a href="#在ARM的汇编程序中，有如下几种伪指令：、-、-、-、-。" class="headerlink" title="在ARM的汇编程序中，有如下几种伪指令：、_、__、__、__。"></a>在ARM的汇编程序中，有如下几种伪指令：<strong><strong><em>、_</em></strong></strong>、<strong>__</strong>、<strong>__</strong>、<strong>__</strong>。</h2><p>答案：符号定义伪指令、数据定义伪指令、汇编控制伪指令、宏指令、其他伪指令</p>
<h2 id="协处理器主要控制：-、-、-。"><a href="#协处理器主要控制：-、-、-。" class="headerlink" title="协处理器主要控制：__、__、__。"></a>协处理器主要控制：<strong>__</strong>、<strong>__</strong>、<strong>__</strong>。</h2><p>答案：片内的MMU、指令和数据缓存（IDC）、写缓冲（Write Buffer）</p>
<h2 id="当一个异常出现以后，ARM微处理器会执行哪几步操作？"><a href="#当一个异常出现以后，ARM微处理器会执行哪几步操作？" class="headerlink" title="当一个异常出现以后，ARM微处理器会执行哪几步操作？"></a>当一个异常出现以后，ARM微处理器会执行哪几步操作？</h2><p>答：当一个异常出现以后，ARM微处理器会执行以下几步操作。<br>A、将下一条指令的地址存入相应连接寄存器LR，以便程序在处理异常返回时能从正确的位置重新开始执行。若异常是从ARM状态进入，则LR寄存器中保存 的是下一条指令的地址（当前PC＋4或PC＋8，与异常的类型有关）；若异常是从Thumb状态进入，则在LR寄存器中保存当前PC的偏移量，这样，异常 处理程序就不需要确定异常是从何种状态进入的。例如：在软件中断异常SWI，指令 MOV PC，R14_svc总是返回到下一条指令，不管SWI是在ARM状态执行，还是在Thumb状态执行。<br>B、将CPSR复制到相应的SPSR中。<br>C、根据异常类型，强制设置CPSR的运行模式位。<br>D、强制PC从相关的异常向量地址取下一条指令执行，从而跳转到相应的异常处理程序处。</p>
<h2 id="ARM微处理器在较新的体系结构中支持两种指令集：-、-。"><a href="#ARM微处理器在较新的体系结构中支持两种指令集：-、-。" class="headerlink" title="ARM微处理器在较新的体系结构中支持两种指令集：__、__。"></a>ARM微处理器在较新的体系结构中支持两种指令集：<strong>__</strong>、<strong>__</strong>。</h2><p>答案：ARM指令集、Thumb指令集</p>
<h2 id="ARM处理器有9种基本寻址方式，分别是：-、-、-、-、-、-、-、-、-。"><a href="#ARM处理器有9种基本寻址方式，分别是：-、-、-、-、-、-、-、-、-。" class="headerlink" title="ARM处理器有9种基本寻址方式，分别是：__、__、__、__、__、__、__、__、__。"></a>ARM处理器有9种基本寻址方式，分别是：<strong>__</strong>、<strong>__</strong>、<strong>__</strong>、<strong>__</strong>、<strong>__</strong>、<strong>__</strong>、<strong>__</strong>、<strong>__</strong>、<strong>__</strong>。</h2><p>答案：寄存器寻址、立即寻址、寄存器偏移寻址、寄存器间接寻址、基址寻址、多寄存器寻址、堆栈寻址、块拷贝寻址、相对寻址</p>
<h2 id="ARM指令集可以分为6类，分别是：-、-、-、-、-、-。"><a href="#ARM指令集可以分为6类，分别是：-、-、-、-、-、-。" class="headerlink" title="ARM指令集可以分为6类，分别是：__、__、__、__、__、__。"></a>ARM指令集可以分为6类，分别是：<strong>__</strong>、<strong>__</strong>、<strong>__</strong>、<strong>__</strong>、<strong>__</strong>、<strong>__</strong>。</h2><p>答案：跳转指令、数据处理指令、程序状态寄存器（PSR）传输指令、Load/Store指令、协处理器指令、异常中断产生指令</p>
<h2 id="表示递增和递减的满堆栈和空堆栈有哪几种组合，请比较它们的特点。"><a href="#表示递增和递减的满堆栈和空堆栈有哪几种组合，请比较它们的特点。" class="headerlink" title="表示递增和递减的满堆栈和空堆栈有哪几种组合，请比较它们的特点。"></a>表示递增和递减的满堆栈和空堆栈有哪几种组合，请比较它们的特点。</h2><p>答：有4种类型的堆栈，表示递增和递减的满堆栈和空堆栈的各种组合。</p>
<ul>
<li>满递增：堆栈通过增大存储器的地址向上增长，堆栈指针指向内含有效数据项的最高地址。指令如LDMFA，STMFA等。</li>
<li>空递增：堆栈通过增大存储器的地址向上增长，堆栈指针指向堆栈上的第一个空地址。指令如LDMEA，STMEA等。</li>
<li>满递减：堆栈通过减小存储器的地址向下增长，堆栈指针指向内含有效数据项的最低地址。指令如LDMFD，STMFD等。</li>
<li>空递减：堆栈通过减小存储器的地址向下增长，堆栈指针指向堆栈下的第一个空地址。指令如LDMED，STMED等。</li>
</ul>
<h2 id="ARM协处理器指令包括哪3类，请描述它们的功能。"><a href="#ARM协处理器指令包括哪3类，请描述它们的功能。" class="headerlink" title="ARM协处理器指令包括哪3类，请描述它们的功能。"></a>ARM协处理器指令包括哪3类，请描述它们的功能。</h2><p>答：ARM协处理器指令包括以下3类：</p>
<ul>
<li>用于ARM处理器初始化ARM协处理器的数据处理操作。</li>
<li>用于ARM处理器的寄存器和ARM协处理器的寄存器间的数据传送操作。</li>
<li>用于在ARM协处理器的寄存器和内存单元之间传送数据。</li>
</ul>
<p>14、可执行映像文件通常由几部分构成，它们有什么特点？</p>
<p>答：可执行映像文件通常由以下几部分构成。<br>    一个或多个代码段，代码段的属性为只读。<br>    零个或多个包含初始化数据的数据段，数据段的属性为可读写。<br>    零个或多个不包含初始化数据的数据段，数据段的属性为可读写。</p>
<h2 id="ARM嵌入式系统主要由-、-和-构成。"><a href="#ARM嵌入式系统主要由-、-和-构成。" class="headerlink" title="ARM嵌入式系统主要由__、__和__构成。"></a>ARM嵌入式系统主要由<strong>__</strong>、<strong>__</strong>和<strong>__</strong>构成。</h2><p>答案：嵌入式处理器、相关支撑硬件、嵌入式软件系统</p>
<h2 id="总线通常包括-、-和-。"><a href="#总线通常包括-、-和-。" class="headerlink" title="总线通常包括__、__和__。"></a>总线通常包括<strong>__</strong>、<strong>__</strong>和<strong>__</strong>。</h2><p>答案：数据总线、地址总线、控制总线</p>
<h2 id="复位后，ARM处理器处于（B）模式，（D）状态"><a href="#复位后，ARM处理器处于（B）模式，（D）状态" class="headerlink" title="复位后，ARM处理器处于（B）模式，（D）状态"></a>复位后，ARM处理器处于（B）模式，（D）状态</h2><p>A、user B、SVC C、system D、ARM E、Thumb</p>
<h2 id="ARM处理器中优先级别最高的异常为（E）"><a href="#ARM处理器中优先级别最高的异常为（E）" class="headerlink" title="ARM处理器中优先级别最高的异常为（E）"></a>ARM处理器中优先级别最高的异常为（E）</h2><p>A、FIQ     B、SWI     C、IRQ     D、SVC     E、RESET</p>
<h2 id="ATPCS规定中，栈是（B）"><a href="#ATPCS规定中，栈是（B）" class="headerlink" title="ATPCS规定中，栈是（B）"></a>ATPCS规定中，栈是（B）</h2><p>A、满加    B、满减    C、空加    D、空减</p>
<h2 id="CPU复位后执行MOV-R0，PC指令后，R0寄存器的值为（C）"><a href="#CPU复位后执行MOV-R0，PC指令后，R0寄存器的值为（C）" class="headerlink" title="CPU复位后执行MOV R0，PC指令后，R0寄存器的值为（C）"></a>CPU复位后执行MOV R0，PC指令后，R0寄存器的值为（C）</h2><p>A、0x0    B、0x4    C、0x8    D、0xC</p>
<h2 id="ARM中可以访问状态寄存器的指令是（D），能够访问内存的指令是（B）"><a href="#ARM中可以访问状态寄存器的指令是（D），能够访问内存的指令是（B）" class="headerlink" title="ARM中可以访问状态寄存器的指令是（D），能够访问内存的指令是（B）"></a>ARM中可以访问状态寄存器的指令是（D），能够访问内存的指令是（B）</h2><p>A、MOV    B、LDR    C、MCR    D、MRS</p>
<h2 id="ARM7TDMI使用3级流水线，分3个阶段，分别为取指、译码和-执行。"><a href="#ARM7TDMI使用3级流水线，分3个阶段，分别为取指、译码和-执行。" class="headerlink" title="ARM7TDMI使用3级流水线，分3个阶段，分别为取指、译码和 执行。"></a>ARM7TDMI使用3级流水线，分3个阶段，分别为取指、译码和 执行。</h2><h2 id="中断向量是指（C-）。"><a href="#中断向量是指（C-）。" class="headerlink" title="中断向量是指（C　）。"></a>中断向量是指（C　）。</h2><p>A、中断断点的地址                 B、中断向量表起始地址<br>C、中断处理程序入口地址         D、中断返回地址　</p>
<h2 id="ROM-RAM的概念浅析"><a href="#ROM-RAM的概念浅析" class="headerlink" title="ROM RAM的概念浅析"></a>ROM RAM的概念浅析</h2><ul>
<li>ROM<br>  存储固化程序的，存放指令代码和一些固定数值，程序运行后不可改动。<br>  c文件及h文件中所有代码、全局变量、局部变量、’const’限定符定义的常量数据、startup.asm文件中的代码（类似ARM中的bootloader或者X86中的BIOS，一些低端的单片机是没有这个的）通通都存储在ROM中。</li>
<li>RAM<br>  程序运行中数据的随机存取（掉电后数据消失），整个程序中，所用到的需要被改写的量，都存储在 RAM 中，“被改变的量”包括全局变量、局部变量、堆栈段。</li>
</ul>
<h2 id="波特率是什么，为什么双方波特率要相同，高低波特率有什么区别"><a href="#波特率是什么，为什么双方波特率要相同，高低波特率有什么区别" class="headerlink" title="波特率是什么，为什么双方波特率要相同，高低波特率有什么区别"></a>波特率是什么，为什么双方波特率要相同，高低波特率有什么区别</h2><p>波特率：即单位时间内传输的符号个数。异步通讯中由于没有时钟信号接口中是没有时钟信号的)，所以两个通讯设备之间需要约定好波特率，即每个码元的长度。常见的波特率为4800、 9600、 115200 等。波特率越高传输速度越快，可靠性降低。</p>
<h2 id="IIC-SPI-UART时序图"><a href="#IIC-SPI-UART时序图" class="headerlink" title="IIC\SPI\UART时序图"></a>IIC\SPI\UART时序图</h2><p>看博客通信协议分类</p>
<h2 id="什么是异步串口和同步串口"><a href="#什么是异步串口和同步串口" class="headerlink" title="什么是异步串口和同步串口"></a>什么是异步串口和同步串口</h2><ul>
<li><p>异步通信：<br>  异步通信中的接收方并不知道数据什么时候会到达，收发双方可以有各自自己的时钟。发送方发送的时间间隔可以不均，接收方是在数据的起始位和停止位的帮助下实现信息同步的。这种传输通常是很小的分组，比如一个字符为一组，为这个组配备起始位和结束位。所以这种传输方式的效率是比较低的，毕竟额外加入了很多的辅助位作为负载，常用在低速的传输中。<br>  举个例子，我们的键盘按下一个按键，发出一个字符信号，异步传输机制就会为它加上前后的辅助同步信息，帮助接收方识别到我们按下了哪一个按键。因为我们敲击键盘的节奏不固定，所以异步是一种很适合的方式。</p>
</li>
<li><p>同步通信：<br>  同步通信中双方使用频率一致的时钟，它的分组相比异步则大得多，称为一个数据帧，通过独特的bit串作为启停标识。发送方要以固定的节奏去发送数据，而接收方要时刻做好接收数据的准备，识别到前导码后马上要开始接收数据了。同步这种方式中因为分组很大，很长一段数据才会有额外的辅助位负载，所以效率更高，更加适合对速度要求高的传输，当然这种通信对时序的要求也更高。</p>
</li>
</ul>
<h2 id="IO口工作方式"><a href="#IO口工作方式" class="headerlink" title="IO口工作方式"></a>IO口工作方式</h2><ul>
<li>上拉输入：上拉就是把电位拉高，比如拉到Vcc。上拉就是将不确定的信号通过一个电阻嵌位在高电平！电阻同时起限流作用！弱强只是上拉电阻的阻值不同，没有什么严格区分。</li>
<li>下拉输入：就是把电压拉低，拉到GND。与上拉原理相似。</li>
<li>浮空输入：浮空（floating）就是逻辑器件的输入引脚即不接高电平，也不接低电平。由于逻辑器件的内部结构，当它输入引脚悬空时，相当于该引脚接了高电平。一般实际运用时，引脚不建议悬空，易受干扰。 通俗讲就是让管脚什么都不接，浮空着。</li>
<li>模拟输入：模拟输入是指传统方式的输入.数字输入是输入PCM数字信号,即0,1的二进制数字信号,通过数模转换,转换成模拟信号,经前级放大进入功率放大器,功率放大器还是模拟的。</li>
<li>推挽输出:可以输出高,低电平,连接数字器件; 推挽结构一般是指两个三极管分别受两互补信号的控制,总是在一个三极管导通的时候另一个截止。高低电平由IC的电源低定。</li>
<li>开漏输出:输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20mA以内).</li>
<li>复用输出：可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）。端口必须配置成复用功能输出模式(推挽或开漏)。<br><img src="/images/26.png" alt=""></li>
</ul>
<h2 id="CPU内部结构"><a href="#CPU内部结构" class="headerlink" title="CPU内部结构"></a>CPU内部结构</h2><ul>
<li>算术逻辑单元<br>  是计算机的运算器，它完成算术运算和逻辑运算两种操作。<br>  逻辑运算是通过比较来完成的，即两个数据进行比较，判断是否等于、小于或大于等。算术运算包括加、减、乘、除等运算，实际上算术逻辑单元使用一个或多个加法器来完成加、减、乘、除等运算。</li>
<li>寄存器<br>  寄存器是微处理器作算术运算和逻辑运算时，用来临时寄存中间数据和地址的存储位置。它们的硬件组成类似于内存的存储单元，只是存取速度比内存的更快，容量更小。寄存器通常放在CPU内部，并由控制器控制。</li>
<li>控制器<br>  控制器是协调和控制出现在中央处理器中的所有操作。控制器并不输入、输出、处理或存储数据，而是启动和控制这些操作的顺序。此外，为了启动在存储器和输入输出设备之间进行数据或指令传送，控制器必须和输入输出设备进行通信。</li>
</ul>
<h2 id="中断怎么发生，中断处理大概流程"><a href="#中断怎么发生，中断处理大概流程" class="headerlink" title="中断怎么发生，中断处理大概流程"></a>中断怎么发生，中断处理大概流程</h2><ul>
<li>中断是指由于接收到来自外围硬件（相对于中央处理器和内存）的异步信号或来自软件的同步信号，而进行相应的硬件／软件处理。发出这样的信号称为进行中断请求</li>
<li>每当一个中断发生以后，ARM处理器便强制把PC指针置为向量表中对应中断类型的地址值(中断服务函数)，然后在进入中断前会把cpu许多寄存器状态压入堆栈，中断结束后取出寄存器的值，确保cpu工作状态和进入中断前一样。函数调用只在堆栈压入下一条指令的地址，不保存其他寄存器的数据，cpu工作状态会变<br>因为编译时无法确定中断发生的时间，所以要还原工作状态</li>
</ul>
<h2 id="中断与异常有何区别"><a href="#中断与异常有何区别" class="headerlink" title="中断与异常有何区别"></a>中断与异常有何区别</h2><ul>
<li>中断：中断是指来自CPU执行指令以外的事件发生后，处理机暂停正在运行的程序，转去执行处理该事件的程序的过程。</li>
<li>异常：异常是指源自CPU执行指令内部的事件发生后，处理机暂停正在运行的程序，转去执行该事件的过程。</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>表和元表</title>
    <url>/2020/06/15/%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><p>table 是Lua的一种数据结构用来帮助我们创建不同的数据类型，如：数组、字典等。<br>Lua table使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。<br>Lua table 是不固定大小的，你可以根据自己需要进行扩容。</p>
<h2 id="table-表-的构造"><a href="#table-表-的构造" class="headerlink" title="table(表)的构造"></a>table(表)的构造</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 初始化表</span></span><br><span class="line">mytable = &#123;&#125;</span><br><span class="line"></span><br><span class="line">a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;  <span class="comment">--索引默认为1，2，3</span></span><br><span class="line">a[<span class="string">"c"</span>]=<span class="string">"cc"</span>  <span class="comment">--a.c----&gt;cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定值</span></span><br><span class="line">mytable[<span class="number">1</span>]= <span class="string">"Lua"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 移除引用</span></span><br><span class="line">mytable = <span class="literal">nil</span></span><br><span class="line"><span class="comment">-- lua 垃圾回收会释放内存</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="Table-操作"><a href="#Table-操作" class="headerlink" title="Table 操作"></a>Table 操作</h2><ul>
<li>table.concat (table [, sep [, start [, end]]]):<br>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">fruits = &#123;<span class="string">"banana"</span>,<span class="string">"orange"</span>,<span class="string">"apple"</span>&#125;</span><br><span class="line"><span class="comment">-- 返回 table 连接后的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"连接后的字符串 "</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定连接字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"连接后的字符串 "</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits,<span class="string">", "</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定索引来连接 table</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"连接后的字符串 "</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits,<span class="string">", "</span>, <span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure></li>
<li>table.insert (table, [pos,] value):<br>在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</li>
<li>table.maxn (table)<br>指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现)</li>
<li>table.remove (table [, pos])<br>返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</li>
<li>table.sort (table [, comp])<br>对给定的table进行升序排序。</li>
</ul>
<h1 id="Lua-元表-Metatable"><a href="#Lua-元表-Metatable" class="headerlink" title="Lua 元表(Metatable)"></a>Lua 元表(Metatable)</h1><p>元表 (metatable) 的表现行为类似于 C++ 语言中的操作符重载，例如我们可以重载 “__add” 元方法 (metamethod)，来计算两个 Lua 数组的并集；或者重载 “__index”方法，来定义我们自己的 Hash 函数<br>在Lua table中我们可以访问对应的key来得到value值，但是却无法对两个table进行操作。因此Lua提供了元表，允许我们改变table的行为，每个行为关联了对应的元方法。Lua中的每个值都可以有一个元表。这个元表就是一个普通的Lua表，它用于原始值在特定操作下的行为。如果你想改变一个值在特定操作下的行为，你可以在它的元表中设置对应域。例如，使用元表我们可以定义Lua如何计算两个table的相加操作a+b。当Lua试图对两个表进行相加时，先检查两者之一是否有元表，之后检查是否有一个叫”__add”的字段，若找到，则调用对应的值。”__add “等即时字段，其对应的值（往往是一个函数或是table）就是”元方法”.提供了两个十分重要的用来处理元表的方法，如下：</p>
<ul>
<li><p>setmetatable(table,metatable): 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。</p>
</li>
<li><p>getmetatable(table): 返回对象的元表(metatable)。</p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = &#123;&#125;                          <span class="comment">-- 普通表</span></span><br><span class="line">mymetatable = &#123;&#125;                      <span class="comment">-- 元表</span></span><br><span class="line"><span class="built_in">setmetatable</span>(mytable,mymetatable)     <span class="comment">-- 把 mymetatable 设为 mytable 的元表</span></span><br></pre></td></tr></table></figure>
<p>以上代码也可以直接写成一行：<br><code>mytable = setmetatable({},{})</code><br>以下为返回对象元表：<br><code>getmetatable(mytable)                 -- 这回返回mymetatable</code></p>
<h2 id="index-元方法"><a href="#index-元方法" class="headerlink" title="__index 元方法"></a>__index 元方法</h2><p>访问一个table的字段时，如果table有这个字段，直接返回对应的值；<br>当table没有这个字段，就会去找table的元表的__index,没有找到返回nil。<br>如果有的话分两种情况，__index可以是方法也可以是一个table</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ lua</span><br><span class="line">Lua <span class="number">5.3</span><span class="number">.0</span>  Copyright (C) <span class="number">1994</span><span class="number">-2015</span> Lua.org, PUC-Rio</span><br><span class="line">&gt; other = &#123; foo = <span class="number">3</span> &#125;</span><br><span class="line">&gt; t = setmetatable(&#123;&#125;, &#123; __index = other &#125;)</span><br><span class="line">&gt; t.foo</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; t.bar</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>
<p>如果<strong>index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。<br>__index 元方法查看表中元素是否存在，如果不存在，返回结果为 nil；如果存在则由 \</strong>index 返回结果。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;key1 = <span class="string">"value1"</span>&#125;, &#123;</span><br><span class="line">  <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(mytable, key)</span></span></span><br><span class="line">    <span class="keyword">if</span> key == <span class="string">"key2"</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"metatablevalue"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>
<p>实例解析：</p>
<ul>
<li>mytable 表赋值为 {key1 = “value1”}。</li>
<li>mytable 设置了元表，元方法为 __index。<br>在mytable表中查找 key1，如果找到，返回该元素，找不到则继续。</li>
<li>在mytable表中查找 key2，如果找到，返回 metatablevalue，找不到则继续。</li>
<li>判断元表有没有__index方法，如果__index方法是一个函数，则调用该函数。</li>
<li>元方法中查看是否传入 “key2” 键的参数（mytable.key2已设置），如果传入 “key2” 参数返回 </li>
</ul>
<p>“metatablevalue”，否则返回 mytable 对应的键值。<br>我们可以将以上代码简单写成：<code>mytable = setmetatable({key1 = &quot;value1&quot;}, { __index = { key2 = &quot;metatablevalue&quot; } })</code></p>
<h2 id="newindex-元方法"><a href="#newindex-元方法" class="headerlink" title="__newindex 元方法"></a>__newindex 元方法</h2><p>__newindex 元方法用来对表更新，__index则用来对表访问 。<br>当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则调用这个函数而不进行赋值操作。<br>以下实例演示了 __newindex 元方法的应用：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">mymetatable = &#123;&#125;</span><br><span class="line">mytable = setmetatable(&#123;key1 = <span class="string">"value1"</span>&#125;, &#123; __newindex = mymetatable &#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(mytable.key1)</span></span></span><br><span class="line"></span><br><span class="line">mytable<span class="selector-class">.newkey</span> = <span class="string">"新值2"</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(mytable.newkey,mymetatable.newkey)</span></span></span><br><span class="line"></span><br><span class="line">mytable<span class="selector-class">.key1</span> = <span class="string">"新值1"</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(mytable.key1,mymetatable.key1)</span></span></span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">value1</span><br><span class="line">nil    新值<span class="number">2</span></span><br><span class="line">新值<span class="number">1</span>    nil</span><br></pre></td></tr></table></figure>
<p>以上实例中表设置了元方法 __newindex，在对新索引键（newkey）赋值时（mytable.newkey = “新值2”），会调用元方法，而不进行赋值。而如果对已存在的索引键（key1），则会进行赋值，而不调用元方法 __newindex。</p>
<h2 id="call-元方法"><a href="#call-元方法" class="headerlink" title="__call 元方法"></a>__call 元方法</h2><p>__call 元方法在 Lua 调用一个值时调用。</p>
<h2 id="修改表的操作符行为"><a href="#修改表的操作符行为" class="headerlink" title="修改表的操作符行为"></a>修改表的操作符行为</h2><p>通过重载 “__add” 元方法来计算集合的并集实例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> set1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;   <span class="comment">-- 集合</span></span><br><span class="line"><span class="keyword">local</span> set2 = &#123;<span class="number">20</span>, <span class="number">40</span>, <span class="number">50</span>&#125;   <span class="comment">-- 集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将用于重载__add的函数，注意第一个参数是self</span></span><br><span class="line"><span class="keyword">local</span> union = <span class="function"><span class="keyword">function</span> <span class="params">(self, another)</span></span></span><br><span class="line">    <span class="keyword">local</span> set = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> result = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 利用数组来确保集合的互异性</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">pairs</span>(self) <span class="keyword">do</span> set[j] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">pairs</span>(another) <span class="keyword">do</span> set[j] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 加入结果集合</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">pairs</span>(set) <span class="keyword">do</span> <span class="built_in">table</span>.<span class="built_in">insert</span>(result, i) <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">setmetatable</span>(set1, &#123;<span class="built_in">__add</span> = union&#125;) <span class="comment">-- 重载 set1 表的 __add 元方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> set3 = set1 + set2</span><br><span class="line"><span class="keyword">for</span> _, j <span class="keyword">in</span> <span class="built_in">pairs</span>(set3) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(j..<span class="string">" "</span>)               <span class="comment">--&gt;output：30 50 20 40 10</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>除了加法可以被重载之外，Lua 提供的所有操作符都可以被重载：</p>
<table>
<thead>
<tr>
<th>元方法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>“__add”</td>
<td>+ 操作</td>
</tr>
<tr>
<td>“__sub”</td>
<td>- 操作 其行为类似于 “add” 操作</td>
</tr>
<tr>
<td>“__mul”</td>
<td>* 操作 其行为类似于 “add” 操作</td>
</tr>
<tr>
<td>“__div”</td>
<td>/ 操作 其行为类似于 “add” 操作</td>
</tr>
<tr>
<td>“__mod”</td>
<td>% 操作 其行为类似于 “add” 操作</td>
</tr>
<tr>
<td>“__pow”</td>
<td>^ （幂）操作 其行为类似于 “add” 操作</td>
</tr>
<tr>
<td>“__unm”</td>
<td>一元 - 操作</td>
</tr>
<tr>
<td>“__len”</td>
<td># 操作</td>
</tr>
<tr>
<td>“__eq”</td>
<td>== 操作 函数 getcomphandler 定义了 Lua 怎样选择一个处理器来作比较操作</td>
</tr>
<tr>
<td>“__lt”</td>
<td>&lt; 操作</td>
</tr>
<tr>
<td>“__le”</td>
<td>&lt;= 操作</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言篇</title>
    <url>/2020/06/21/%E9%9D%A2%E8%AF%95C%E8%AF%AD%E8%A8%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="一个程序从开始运行到结束的完整过程"><a href="#一个程序从开始运行到结束的完整过程" class="headerlink" title="一个程序从开始运行到结束的完整过程"></a>一个程序从开始运行到结束的完整过程</h2><ul>
<li>预处理（.i文件）<br>在编译的时候会被尾开去换成空际的代码这个层开编译的时候会被展开替换成实际的代码,这个展升的步骤就是在预处理的时候进行的当然预处理并不仅仅只是做宏的展开，它还做了类似头文件插入<br>预处理之后的产品依然还是C/C++代码,它在代码的逻辑上和输入的C/C++源代码是完全- -样的. </li>
<li>汇编 (.s文件)<br>汇编语言是将机器语言符号化了的语言是机器不能直接识别的低级语言我们可以通过下面的命令将预处理后的代码编译成汇编语言:</li>
<li>编译（.o文件，目标文件）<br>汇编这一步是将汇编代码编译成机器语言:</li>
<li>链接<br>c语言写的程序需要依赖各种库，所以编译后还需要把库链接到最终的可执行程序中去</li>
</ul>
<a id="more"></a>

<h2 id="预处理器（Preprocessor）"><a href="#预处理器（Preprocessor）" class="headerlink" title="预处理器（Preprocessor）"></a>预处理器（Preprocessor）</h2><ol>
<li>用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）<br><code>#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</code></li>
</ol>
<p>我在这想看到几件事情：<br>1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）<br>2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。<br>3). 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。<br>4). 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。</p>
<h2 id="写一个“标准”宏MIN-MAX，这个宏输入两个参数并返回较小-大的一个。"><a href="#写一个“标准”宏MIN-MAX，这个宏输入两个参数并返回较小-大的一个。" class="headerlink" title="写一个“标准”宏MIN/MAX，这个宏输入两个参数并返回较小/大的一个。"></a>写一个“标准”宏MIN/MAX，这个宏输入两个参数并返回较小/大的一个。</h2><p><code>#define MIN(A,B) ((A) &lt;= (B) (A) : ))</code><br><code>#define Max(a, b) (a &gt; b ? a : b)</code></p>
<p>1). 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。<br>2). 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。<br>3). 懂得在宏中小心地把参数用括号括起来</p>
<h2 id="预处理器标识-error的目的是什么？"><a href="#预处理器标识-error的目的是什么？" class="headerlink" title="预处理器标识#error的目的是什么？"></a>预处理器标识#error的目的是什么？</h2><pre><code>停止编译并显示错误信息</code></pre><h2 id="嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？"><a href="#嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？" class="headerlink" title="嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？"></a>嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？</h2><p>这个问题用几个解决方案。我首选的方案是：<br>while(1) { }<br>一些程序员更喜欢如下方案：<br>for(;;) { }<br>这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的<br>基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。<br>第三个方案是用 goto<br>Loop:<br>…<br>goto Loop;<br>应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。</p>
<p>数据声明（Data declarations）</p>
<h2 id="用变量a给出下面的定义"><a href="#用变量a给出下面的定义" class="headerlink" title="用变量a给出下面的定义"></a>用变量a给出下面的定义</h2><p>a) 一个整型数（An integer）<br>b) 一个指向整型数的指针（A pointer to an integer）<br>c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）<br>d) 一个有10个整型数的数组（An array of 10 integers）<br>e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）<br>f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）<br>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）<br>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）</p>
<p>答案是：<br>a) int a; // An integer<br>b) int <em>a; // A pointer to an integer<br>c) int *</em>a; // A pointer to a pointer to an integer<br>d) int a[10]; // An array of 10 integers<br>e) int <em>a[10]; // An array of 10 pointers to integers<br>f) int (</em>a)[10]; // A pointer to an array of 10 integers<br>g) int (<em>a)(int); // A pointer to a function a that takes an integer argument and returns an integer<br>h) int (</em>a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer</p>
<h2 id="关键字static的作用是什么？"><a href="#关键字static的作用是什么？" class="headerlink" title="关键字static的作用是什么？"></a>关键字static的作用是什么？</h2><p>这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：<br>1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。<br>2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。<br>3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。<br>大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。</p>
<h2 id="关键字const是什么含意？"><a href="#关键字const是什么含意？" class="headerlink" title="关键字const是什么含意？"></a>关键字const是什么含意？</h2><p>只要一个变量前用const来修饰，就意味着该变量里的数据只能被访问，而不能被修改，也就是意味着const“只读”</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a; <span class="comment">//const靠近*，地址内容不可变，地址可变，*a=100//err ；a=NULL//OK</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;<span class="comment">//看const靠近*还是a，靠近a表示地址可变，地址里面的内容不可变，</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * a <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>
<p>前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。：<br>1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）<br>2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。<br>3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</p>
<h2 id="关键字volatile有什么含意-并给出三个不同的例子。"><a href="#关键字volatile有什么含意-并给出三个不同的例子。" class="headerlink" title="关键字volatile有什么含意 并给出三个不同的例子。"></a>关键字volatile有什么含意 并给出三个不同的例子。</h2><p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p>
<ol>
<li>并行设备的硬件寄存器（如：状态寄存器）</li>
<li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</li>
<li>多线程应用中被几个任务共享的变量<br>假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。<br>1). 一个参数既可以是const还可以是volatile吗？解释为什么。<br>2). 一个指针可以是volatile 吗？解释为什么。<br>下面是答案：<br>1). volatile修饰符告诉complier变量值可以以任何不被程序明确指明的方式改变，最常见的例子就是外部端口的值，它的变化可以不用程序内的任何赋值语句就有可能改变的，这种变量就可以用volatile来修饰，complier不会优化掉它。<br>const修饰的变量在程序里面是不能改变的，但是可以被程序外的东西修改，就象上面说的外部端口的值，如果仅仅使用const，有可能complier会优化掉这些变量，加上volatile就万无一失了。<br>2). 可以。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。</li>
</ol>
<h2 id="位操作（Bit-manipulation）"><a href="#位操作（Bit-manipulation）" class="headerlink" title="位操作（Bit manipulation）"></a>位操作（Bit manipulation）</h2><p>嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 (0x1&lt;&lt;3) </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">a |= BIT3; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">a &amp;= ~BIT3; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="要求设置一绝对地址为0x67a9的整型变量的值为0xaa55"><a href="#要求设置一绝对地址为0x67a9的整型变量的值为0xaa55" class="headerlink" title="要求设置一绝对地址为0x67a9的整型变量的值为0xaa55"></a>要求设置一绝对地址为0x67a9的整型变量的值为0xaa55</h2><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *<span class="built_in">ptr</span><span class="comment">; </span></span><br><span class="line"><span class="built_in">ptr</span> = (<span class="keyword">int</span> *)<span class="number">0x67a9</span><span class="comment">; </span></span><br><span class="line">*<span class="built_in">ptr</span> = <span class="number">0xaa55</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>


<h2 id="中断函数（Interrupts）"><a href="#中断函数（Interrupts）" class="headerlink" title="中断函数（Interrupts）"></a>中断函数（Interrupts）</h2><p>中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字<strong>interrupt。下面的代码就使用了</strong>interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。<br>__interrupt double compute_area (double radius)<br>{<br>double area = PI * radius * radius;<br>printf(” Area = %f”, area);<br>return area;<br>}<br>这个函数有太多的错误了，以至让人不知从何说起了：<br>1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。<br>2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。<br>3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。<br>4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。</p>
<h2 id="const与-define相比"><a href="#const与-define相比" class="headerlink" title="const与#define相比"></a>const与#define相比</h2><p>1）就起作用的阶段而言：#define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。<br>2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。<br>3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。<br>4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。</p>
<h2 id="typedef与define的区别"><a href="#typedef与define的区别" class="headerlink" title="typedef与define的区别"></a>typedef与define的区别</h2><p>typedef ：typedef是在计算机编程语言中用来为复杂的声明定义简单的别名，它与宏定义有些差异。它本身是一种存储类的关键字，与auto、extern、mutable、static、register等关键字不能出现在同一个表达式中。<br><code>typedef int size;//size就是int类型，定义变量时可以写 size a；</code></p>
<p>typedef是C语言中用来声明自定义数据类型，配合各种原有数据类型来达到简化编程的目的的类型定义关键字。#define是预处理指令，是宏定义。</p>
<h2 id="简介-和-的作用"><a href="#简介-和-的作用" class="headerlink" title="简介##和#的作用"></a>简介##和#的作用</h2><p> ##的作用就是把2个宏参数连接为1个数。<br> #的作用就是讲#后面的宏参数进行字符串的操作，也就是将#后面的参数两边加上一对双引号使其成为字符串。<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> TE(a,b) (a#b)</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> num = TE(<span class="number">12</span>,<span class="number">34</span>);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"num=%d"</span>,num);</span><br><span class="line"> &#125;</span><br><span class="line">输出：num=<span class="number">1234</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TE(param) #param</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> *pstr = TE(<span class="number">1234</span>);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"num=%s"</span>,pstr);</span><br><span class="line"> &#125;</span><br><span class="line"> 输出：sptr=<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h2 id="virtual关键字"><a href="#virtual关键字" class="headerlink" title="virtual关键字"></a>virtual关键字</h2><p>为C++关键字，virtual声明的函数为虚函数，告诉编译器不要静态链接</p>
<h2 id="指针与引用的相同和区别；如何相互转换？"><a href="#指针与引用的相同和区别；如何相互转换？" class="headerlink" title="指针与引用的相同和区别；如何相互转换？"></a>指针与引用的相同和区别；如何相互转换？</h2><p>区别：</p>
<ol>
<li>指针是一个实体，而引用仅是个别名</li>
<li>指针和引用的自增(++)运算意义不一样，指针是对内存地址的自增，引用是对值的自增；<br>量或对象的地址)的大小；</li>
<li>引用使用时无需解引用(*)，指针需要解引用；</li>
<li>引用只能在定义时被初始化一次，之后不可变；指针可变；</li>
<li>引用不能为空，指针可以为空；</li>
<li>引用没有const，指针有const；</li>
<li>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小，在32位系统指针变量一般占用4字节内存。</li>
</ol>
<p>指针和引用之间怎么转换：</p>
<ol>
<li>指针转引用：把指针用*就可以转换成对象，可以用在引用参数当中。</li>
<li>引用转指针：把引用类型的对象用&amp;取地址就获得指针了。</li>
</ol>
<h2 id="h头文件中的ifndef-define-endif-的作用？"><a href="#h头文件中的ifndef-define-endif-的作用？" class="headerlink" title=".h头文件中的ifndef/define/endif 的作用？"></a>.h头文件中的ifndef/define/endif 的作用？</h2><p>答：防止该头文件被重复引用。</p>
<h2 id="全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"><a href="#全局变量和局部变量在内存中是否有区别？如果有，是什么区别？" class="headerlink" title="全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"></a>全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</h2><p>答 ：全局变量储存在静态数据区，局部变量在栈中。</p>
<h2 id="堆栈溢出一般是由什么原因导致的？"><a href="#堆栈溢出一般是由什么原因导致的？" class="headerlink" title="堆栈溢出一般是由什么原因导致的？"></a>堆栈溢出一般是由什么原因导致的？</h2><ul>
<li>没有回收垃圾资源</li>
<li>层次太深的递归调用</li>
</ul>
<h2 id="程序的内存分配"><a href="#程序的内存分配" class="headerlink" title="程序的内存分配"></a>程序的内存分配</h2><p>答：一个由C/C++编译的程序占用的内存分为以下几个部分</p>
<ul>
<li>栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。函数执行结束时这些存储单元自动释放。</li>
<li>堆分配（又称动态内存分配）。程序在运行时用malloc或者new申请内存，程序员自己用free或者delete释放，动态内存的生存期由我们自己决定。</li>
<li>全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。内存分配在程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等。</li>
</ul>
<h2 id="在1G内存的计算机中能否malloc-1-2G-？为什么？"><a href="#在1G内存的计算机中能否malloc-1-2G-？为什么？" class="headerlink" title="在1G内存的计算机中能否malloc(1.2G)？为什么？"></a>在1G内存的计算机中能否malloc(1.2G)？为什么？</h2><p>答：是有可能申请1.2G的内存的。<br>解析：回答这个问题前需要知道malloc的作用和原理，应用程序通过malloc函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接关系，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的。</p>
<p>*Mmu的作用是把虚拟地址映射到物理地址，当程序开始运行会产生进程同时产生虚拟内存(虚拟内存可以比物理内存大)，编程的时候我们使用的为虚拟地址（比如0xd8884）<br>MMU把这个虚拟地址对应到实际地址上，加载cpu时从实际地址上取</p>
<ul>
<li>虚拟内存：为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。<br>创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟 进程地址空间。 之所以是 4GB ，是因为在 32 位的操作系统中，一个指针长度是 4 字节  （32位）， 2的32次 方个地址寻址能力是从 0x00000000~0xFFFFFFFF 即为 4GB 大小的容量。32位Linux下，一个进程空间4G，内核占1G，用户留3G，一个线程默认8M，所以最多380个左右线程。</li>
</ul>
<p>用户3GB：<br>1）栈空间：特点是由系统管理，先进后出，里面放了局部变量、函数形参、自动变量。<br>2）堆空间：特点是由用户管理，先进后出，我们可以用malloc、ralloc、calloc来分配空间。<br>3）数据段：数据段里面又分三块，第一块是bss，保存未初始化的全局变量；第二块是rodata，保存了常量；第三块  是.data（静态数据区）保存了初始化的全局变量还有static修饰的变量。<br>4）代码段：存放了源代码。</p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>答：堆（heap）和栈(stack)的区别</p>
<ol>
<li>申请方式<br>stack:由系统自动分配。例如，声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间<br>heap:需要程序员自己申请，并指明大小，<br>在c中malloc函数<br>如p1=(char*)malloc(10);<br>但是注意p1本身是在栈中的。</li>
<li>申请后系统的响应<br> 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br> 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li>
<li>申请大小的限制<br> 栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域，即栈顶的地址和栈的最大容量是系统预先规定好的，linux系统可以使用ulimit -a命令查看当前系统的栈的大小，默认为10M（64位系统），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<br> 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li>
<li>申请效率的比较：<br> 栈:由系统自动分配，速度较快。但程序员是无法控制的。<br> 堆:是由malloc分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</li>
<li>堆和栈中的存储内容<br> 栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。<br> 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</li>
</ol>
<h2 id="简述数组与指针的区别？"><a href="#简述数组与指针的区别？" class="headerlink" title="简述数组与指针的区别？"></a>简述数组与指针的区别？</h2><p>答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建(不带static的局部数组），malloc的在堆中。指针可以随时指向任意类型的内存块。</p>
<h2 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h2><p>extern只适用于普通全局变量，不能于static一起用<br>static全局变量数据相对安全，外部不能修改<br>头文件声明时加extern定义时不要加，因为extern可以多次声明，但只有一个定义</p>
<h2 id="extern-“C”的作用"><a href="#extern-“C”的作用" class="headerlink" title="extern “C”的作用"></a>extern “C”的作用</h2><p> extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。</p>
<h2 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h2><p>答：</p>
<ol>
<li>new、delete是C++中独有的操作符，而malloc和free是C/C++中的标准库函数。</li>
<li>使用new创建对象在分配内存的时候会自动调用构造函数，同时也可以完成对对象的初始化，同理要记得delete也能自动调用析构函数。因为malloc和 free是库函数而不是运算符，不在编译器控制范围之内，所以不能够自动调用构造函数和析构函数。也就是mallloc只是单纯地为变量分配内存，free也只是释放变量的内存。</li>
<li>new返回的是指定类型的指针，并且可以自动计算所申请内存的大小。而malloc返回的是void*类型，我们需要强行将其转换为实际类型的指针，并且需要指定好要申请内存的大小，malloc不会自动计算的。</li>
<li>C++允许重载new/delete操作符，而malloc和free是一个函数，并不能重载。</li>
<li>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</li>
<li>内存区域：先了解自由存储区和堆，两者不相等于的。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。</li>
</ol>
<h2 id="C-中struct和class的区别"><a href="#C-中struct和class的区别" class="headerlink" title="C++中struct和class的区别"></a>C++中struct和class的区别</h2><p>在C++中，可以用struct和class定义类，都可以继承。<br>区别在于：structural的默认继承权限和默认访问权限<br>是public，而class的默认继承权限和默认访问权限是<br>private。另外，class还可以定义模板类形参，比如<br><code>template &lt;class T, int i&gt;。</code></p>
<h2 id="大小端的区别以及各自的优点，哪种时候用"><a href="#大小端的区别以及各自的优点，哪种时候用" class="headerlink" title="大小端的区别以及各自的优点，哪种时候用"></a>大小端的区别以及各自的优点，哪种时候用</h2><p>1) Little-Endian（小端）就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>2) Big-Endian（大端）就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br>大小端各自的优点</p>
<ul>
<li>小端模式：强制转换数据不需要调整字节内容</li>
<li>大端模式：符号位的判定固定为第一个字节，容易判断正负<br>一般操作系统都是小端，而通讯协议是大端的。</li>
</ul>
<h2 id="计算机怎么算减法-补码的作用"><a href="#计算机怎么算减法-补码的作用" class="headerlink" title="计算机怎么算减法(补码的作用)"></a>计算机怎么算减法(补码的作用)</h2><h2 id="队列和栈的区别"><a href="#队列和栈的区别" class="headerlink" title="队列和栈的区别"></a>队列和栈的区别</h2><ul>
<li>队列是先进先出，只能在一端插入另一端删除，可以从头或尾进行遍历（但不能同时遍历），</li>
<li>栈是先进后出，只能在同一端插入和删除，只能从头部取数据</li>
</ul>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p><img src="/images/27.png" alt=""></p>
<h2 id="char和int之间的转换"><a href="#char和int之间的转换" class="headerlink" title="char和int之间的转换"></a>char和int之间的转换</h2><p>char转int</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch=<span class="string">'9'</span>;</span><br><span class="line"><span class="keyword">int</span> ch_int=ch-<span class="string">'0'</span>;<span class="comment">//此时ch_int=9</span></span><br></pre></td></tr></table></figure>
<p>int转char</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">9</span>；</span><br><span class="line"><span class="keyword">char</span> i_ch=i+<span class="string">'0'</span>;<span class="comment">//此时i_ch='9'</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字符值</th>
<th>ASCII值</th>
</tr>
</thead>
<tbody><tr>
<td>‘0’</td>
<td>48</td>
</tr>
<tr>
<td>‘9’</td>
<td>57</td>
</tr>
<tr>
<td>‘A’</td>
<td>65</td>
</tr>
<tr>
<td>‘Z’</td>
<td>90</td>
</tr>
<tr>
<td>‘a’</td>
<td>97</td>
</tr>
<tr>
<td>‘z’</td>
<td>122</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>嵌入式面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua 面向对象</title>
    <url>/2020/06/16/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">-- Meta <span class="class"><span class="keyword">class</span></span></span><br><span class="line">Shape = &#123;area = <span class="number">0</span>&#125;</span><br><span class="line">-- 基础类方法 <span class="keyword">new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>:</span><span class="keyword">new</span> (o,side)</span><br><span class="line">  o = o <span class="literal">or</span> &#123;&#125;</span><br><span class="line">  setmetatable(o, <span class="built_in">self</span>)</span><br><span class="line">  <span class="built_in">self</span>.__index = <span class="built_in">self</span></span><br><span class="line">  side = side <span class="literal">or</span> <span class="number">0</span></span><br><span class="line">  <span class="built_in">self</span>.area = side*side;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">-- 基础类方法 printArea</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>:</span>printArea ()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"面积为 "</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">myshape = Shape:<span class="keyword">new</span>(nil,<span class="number">10</span>)</span><br><span class="line">myshape:printArea()</span><br><span class="line"></span><br><span class="line">Square = Shape:<span class="keyword">new</span>()</span><br><span class="line">-- 派生类方法 <span class="keyword">new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>:</span><span class="keyword">new</span> (o,side)</span><br><span class="line">  o = o <span class="literal">or</span> Shape:<span class="keyword">new</span>(o,side)</span><br><span class="line">  setmetatable(o, <span class="built_in">self</span>)</span><br><span class="line">  <span class="built_in">self</span>.__index = <span class="built_in">self</span></span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">-- 派生类方法 printArea</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>:</span>printArea ()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"正方形面积为 "</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">mysquare = Square:<span class="keyword">new</span>(nil,<span class="number">10</span>)</span><br><span class="line">mysquare:printArea()</span><br><span class="line"></span><br><span class="line">Rectangle = Shape:<span class="keyword">new</span>()</span><br><span class="line">-- 派生类方法 <span class="keyword">new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>:</span><span class="keyword">new</span> (o,length,breadth)</span><br><span class="line">  o = o <span class="literal">or</span> Shape:<span class="keyword">new</span>(o)</span><br><span class="line">  setmetatable(o, <span class="built_in">self</span>)</span><br><span class="line">  <span class="built_in">self</span>.__index = <span class="built_in">self</span></span><br><span class="line">  <span class="built_in">self</span>.area = length * breadth</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">-- 派生类方法 printArea</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>:</span>printArea ()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"矩形面积为 "</span>,<span class="built_in">self</span>.area)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">myrectangle = Rectangle:<span class="keyword">new</span>(nil,<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">myrectangle:printArea()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">面积为     <span class="number">100</span></span><br><span class="line">正方形面积为     <span class="number">100</span></span><br><span class="line">矩形面积为     <span class="number">200</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。<br>lua 中的 function 可以用来表示方法。那么LUA中的类可以通过 table + function 模拟出来。<br>LUA语言也能继承</p>
]]></content>
      <categories>
        <category>lua语言</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/UDP</title>
    <url>/2020/06/22/TCP%20UDP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个， 之所以命名为TCP/IP协议，因为TCP、IP协议是两个很重要的协议，就用他两命名了。<br>TCP/IP协议集包括应用层,传输层，网络层，网络访问层。<br><img src="/images/38.png" alt=""><br><span id="inline-purple"> 网络层：主要使用ip协议 </span><br><span id="inline-purple"> 传输层:主要使用TCP/UDP协议 </span></p>
<ol>
<li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</li>
<li>数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</li>
<li>网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</li>
<li>传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</li>
<li>会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li>
<li>表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li>
<li>应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。<span id="inline-purple"> 程序开发都在应用层 </span></li>
</ol>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul>
<li>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂</li>
</ul>
<hr>
<ul>
<li>ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。</li>
<li>SYN：用作建立连接时的同步信号</li>
<li>FIN：表示后面没有数据需要发送，通常意昧着所建立的连接需要关闭了。<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><img src="/images/28.png" alt=""><br>换个易于理解的视角来看为什么要3次握手。<br>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</li>
<li>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</li>
<li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</li>
</ul>
<a id="more"></a>

<p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p>
<p>实际情况：</p>
<ol>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</li>
</ol>
<h3 id="为什么需要三次握手，两次不行吗？"><a href="#为什么需要三次握手，两次不行吗？" class="headerlink" title="为什么需要三次握手，两次不行吗？"></a>为什么需要三次握手，两次不行吗？</h3><p>需要三次握手才能确认双方的接收与发送能力是否正常</p>
<hr>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul>
<li>第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；</li>
<li>第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；</li>
<li>第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；</li>
<li>第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。<br><img src="/images/29.png" alt=""></li>
</ul>
<h1 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h1><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><ol>
<li>UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li>
<li>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。</li>
<li>UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。</li>
<li>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。</li>
<li>UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。</li>
<li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。</li>
</ol>
<p><strong><em>例子：QQ发送文件是UDP，打游戏为TCP</em></strong></p>
<h1 id="TCP与UDP的区别："><a href="#TCP与UDP的区别：" class="headerlink" title="TCP与UDP的区别："></a>TCP与UDP的区别：</h1><ol>
<li>基于连接与无连接；</li>
<li>对系统资源的要求（TCP较多，UDP少）；</li>
<li>UDP程序结构较简单；</li>
<li>流模式与数据报模式(TCP数据量大)</li>
<li>TCP保证数据正确性，UDP可能丢包；</li>
<li>TCP保证数据顺序，UDP不保证。</li>
</ol>
<h1 id="TCP和UDP的优缺点"><a href="#TCP和UDP的优缺点" class="headerlink" title="TCP和UDP的优缺点"></a>TCP和UDP的优缺点</h1><ul>
<li><p>TCP的优点：<br>   可靠，稳定TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</p>
</li>
<li><p>UDP的优点：<br>   快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 </p>
</li>
</ul>
<h1 id="什么时候应该使用TCP-UDP"><a href="#什么时候应该使用TCP-UDP" class="headerlink" title="什么时候应该使用TCP/UDP"></a>什么时候应该使用TCP/UDP</h1><p>  当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……</p>
<h1 id="为什么客户端最后还要等待2MSL"><a href="#为什么客户端最后还要等待2MSL" class="headerlink" title="为什么客户端最后还要等待2MSL"></a>为什么客户端最后还要等待2MSL</h1><ul>
<li>保证客户端发送的最后一个ACK报文段能够到达服务端。</li>
<li>防止“已失效的连接请求报文段”出现在本连接中。</li>
</ul>
<h1 id="SYN攻击是什么？"><a href="#SYN攻击是什么？" class="headerlink" title="SYN攻击是什么？"></a>SYN攻击是什么？</h1><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪</p>
<h1 id="挥手为什么需要四次？"><a href="#挥手为什么需要四次？" class="headerlink" title="挥手为什么需要四次？"></a>挥手为什么需要四次？</h1><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>
<h1 id="TCP是如何实现可靠连接的呢？"><a href="#TCP是如何实现可靠连接的呢？" class="headerlink" title="TCP是如何实现可靠连接的呢？"></a>TCP是如何实现可靠连接的呢？</h1><p>TCP协议主要通过检验和、序列号、确认应答（ACK）、重发控制、连接管理、窗口控制等实现可靠性连接。</p>
<h1 id="Http与Https的区别"><a href="#Http与Https的区别" class="headerlink" title="Http与Https的区别"></a>Http与Https的区别</h1><ol>
<li>https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。(网易官网是http，而网易邮箱是https。)</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。（找工作时这个答案一定要说）</li>
<li>http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接受都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</li>
</ol>
<hr>
<p>HTTP：<br>一个客户端和服务器端请求和应答的标准(TCP),用于从WWW服务器传输超文本到本地浏览器的传输协议,减少网络传输,使浏览器更加高效。<br>HTTPS：<br>以安全为目标的HTTP通道,是HTTP的安全版,HTTP下加入SSL层,加密的详细内容就需要SSL。<br>HTTPS协议主要分为两种：一种是建立一个信息安全通道,保证数据传输的安全;另一种是确认网站的真实性。</p>
<hr>
<ul>
<li>HTTP缺点：<br>  通信使用明文，容易被窃听<br>  不验证通信方的身份，可能遭遇伪装<br>  无法证明报文的完整性，有可能遭遇篡改</li>
<li>HTTPS缺点<br>  HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；<br>  https连接缓存不如http高效，如果是大流量网站,则会造成流量成本太高。<br>  https连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用https，基于大部分计算资源闲置的假设的VPS的平均成本会上去。<br>  SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li>
</ul>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>TCP/UDP</tag>
      </tags>
  </entry>
</search>
